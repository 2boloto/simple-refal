# Рекомендации по стилю оформления
Эти рекомендации относятся только к оформлению исходных текстов Простого
Рефала, его рантайма, утилит srmake и lexgen, автотестов и примеров кода,
а также любых других программ, которые будут включаться в этот репозиторий
(за исключением подключения других программ как подмодулей).

В старом коде или в исторической документации могут наблюдаться отклонения
от этих рекомендаций, их не следует исправлять до тех пор, пока старый код
не потребуется изменить. Историческую документацию вообще править не следует.

Рекомендации не навязываются как единственно верные при написании любых
других программ на Простом Рефале или C++.

## Цели, положенные в основу
* Лёгкость чтения.
* Удобство форматирования в примитивных текстовых редакторах.
* Единообразие подхода.

## Глобальные рекомендации, касающиеся документации и исходных текстов
* Максимальная длина строки в текстовых файлах ограничена 80 символами
* Для форматирования не используется табуляция, за исключениев случаев, когда
  этого требует синтаксис языка (т. е. Makefile).
* Использование типографских символов («, », …, длинное тире, неразрывный
  пробел и другие) в документации, комментариях к программам и сообщениям
  коммитов приветствуется, но не требуется.
* Точки над буквой «ё» пишутся всегда.
* Вывод программ на stdout может включать в себя только символы первой половины
  таблицы ASCII (латинские буквы, цифры, знаки препинания).
* Сообщения коммитов пишутся на русском языке.
* Длина сообщения коммита также ограничена 80 символами, но, если есть ссылка
  на задачу (issue), то 76 символами. Если хочется написать больше — пишется
  многострочный коммит, причём первая строка отделяется пустой строкой
  от последующих.
* Ссылка на задачу в сообщении коммита пишется в скобках: (#15).
* Строки в текстовых файлах (исходный код, документация) не должны кончаться
  на пробелы. Обычно, при коммите git об этом предупреждает.

## Общие рекомендации, касающиеся Простого Рефала и C++

* Стандартный отступ равен двум пробелам. Это значит, что любые другие
  отступы должны быть кратны двум пробелам.
* Код не выравнивается по имени функции.

Хорошо:

```
+<FooBar
+  текст внутри идёт с отступом 2 пробела
+>

+void foo_bar(
+  int foo,
+  int bar
+) {

+x = bar_foo(
+  foo, bar
+);
```

Плохо:

```
-<FooBar текст выравнивается
-        по имени функции>

-void foo_bar(int foo,
-             int bar)
-{

-x = bar_foo(foo,
-            bar);
```

* Не рекомендуется использовать имена функций и переменных из одной-двух букв
  или цифр. Имя должно отражать назначение переменной или функции.
* Имена функций и переменных не должны заканчиваться на цифру, если нет на то
  веских оснований (а их, как правило, нет).
  * В Рефале часто пишутся служебные функции, которые вызываются из материнской.
    Вместо имён вида `Func`, `Func1`, `Func2` следует давать имена вида `Func`
    для «основной» функции и `Func-Пояснение` для вспомогательных. `-Пояснение`
    должно отражать смысл этой вспомогательной функции, например,
    `ProcessFileNames-CheckInvalid`. Часто, когда вспомогательная функция одна,
    можно использовать суффикс `-Aux`.

## Рекомендации по оформлению кода на Простом Рефале
* Каждому `$EXTERN`-объявлению должен предшествовать комментарий `//FROM`,
  содержащий имя файна (без расширения), в котором определены эти функции.
  * Следствие: в один список `$EXTERN` не следует включать имена функций,
    импортируемых из разных файлов.
* `$EXTERN`-объявления пишутся в самом начале файла.
* Функции обычно пишутся в порядке от общих к частным. Например, если модуль
  содержит функцию `$ENTRY Go`, то её определение следует непосредственно
  после всех `$EXTERN` объявлений.
  * Исключение: функции, вводимые как `$ENUM`, `$EENUM`, `$SWAP` или `$ESWAP`,
    описываются перед первым их использованием.
  * Короткие функции могут описываться перед первым их использованием, если
    это повышает ясность программы.
* Для имён функций и переменных используется CamelCase. Дефис используется для
  отделения крупных смысловых частей, обычно для вспомогательных функций это имя
  «главной» функции и пояснение предназначения вспомогательной.
  * Подчёркивание («нижнее подчёркивание») в именах функций и переменных
    на Рефале не используется.
  * Для поиска в ассоциативных списках началу и концу списка даётся одно и то же
    имя, с суффиксами `-B` и `-E`, соответственно. Например:

    `e.Names-B (e.Name s.Index) e.Names-E`

    * Если ассоциативный список содержит 3 компоненты, средняя получает суффикс
      `-M`:

      `e.Names-B (e.Name s.Index1) e.Names-M (e.Name s.Index2) e.Names-E`

      Кстати, здесь оправдано использование чисел в именах переменных: два
      вхождения одинаковой по смыслу сущности.
* Определение функции оформляется следующим образом: имя функции, в той же
  строке открывающая фигурная скобка, предложения функции, отдельной строкой
  закрывающая фигурная скобка:
```
ИмяФункции {
  тело функции
}
```
* Образец (левая часть предложения) пишется с одинарным отступом (2 пробела).
* Правая часть пишется либо в той же строке с образцом, либо с новой строки
  с дополнительным отступом (т. е. 4 пробела).

Таким образом, предложение выглядит следующим образом:
```
ИмяФункции {
  …
  ЛеваяЧасть = ПраваяЧасть;
  ДлиннаяДлиннаяЛеваяЧасть =
    ДлиннаяДлиннаяПраваяЧасть;
}
```

* Если выражение (образец или результат) слишком длинное, то разбивается
  по границам термов верхнего уровня.

Правильно (скобочные термы не разбиваются):
```
+  (e.ОднаждыВ t.Студёную s.Зимнюю) s.Пору
+  (t.ЯИзЛесу e.Вышел t.Был s.СильныйМороз)
```
Неправильно (один скобочный терм разбивается):
```
-  (e.ОднаждыВ t.Студёную s.Зимнюю) s.Пору (t.ЯИзЛесу e.Вышел
-  t.Был s.СильныйМороз)
```

* Выражение в скобках можно разбивать на несколько строк, но при этом
  на строках скобками располагаются только скобки, содержимое скобок пишется
  с отступом. Открывающая и закрывающая скобки пишутся в одной колонке.
* Имя функции или АТД считаются частью открывающей скобки. Иногда
  первый терм круглых скобок мыслится как тег типа, он тоже «приклеивается»
  к круглой скобке.

Правильно:
```
+<НарезатьСалатРекурсивный
+  <ПомытьОвощи
+    e.Огурцы e.Помидоры t.Салат
+  >
+  (#Специи
+    (
+      <Майонез>
+      <Сметана>
+    )
+    (
+      [Соль]
+      [Перец
+        #Чёрный
+        #Красный
+      ]
+    )
+  )
+>
```
Неправильно:
```
-<НарезатьСалатРекурсивный <ПомытьОвощи e.Огурцы
-                                       e.Помидоры t.Салат>
-                          (#Специи (<Майонез>
-                                    <Сметана>)
-                          ([Соль]
-                           [Перец #Чёрный
-                           #Красный]))>
```

* Вспомогательные функции, реализующие цикл на хвостовой рекурсии
  (остаточно-рекурсивный цикл), начинаются с префикса `Do`:

```
Fact {
  0 = 1;
  s.N = <DoFact 1 1 s.N>;
}
DoFact {
  s.N s.Prod s.N = <Mul s.N s.Prod>;
  s.K s.Prod s.N =
    <DoFact <Inc s.K> <Mul s.K s.Prod> s.N>;
}
```

* Вспомогательные функции, реализующие выбор в зависимости от условий,
  начинаются с префикса `Sw`. Хотя вместо таких функций рекомендуется
  использовать идиому `Fetch`.
* Вместо остаточно-рекурсивных циклов (см. выше) рекомендуется использовать
  библиотечные функции `Map`, `MapReduce` или `Reduce`, если это не снижает
  читабельность кода.

## Рекомендации по оформлению кода на C++
* Имена типов записываются в CamelCase.
* Имена функций и переменных записываются в_нижнем_регистре_с_подчёркиваниями.
* В фигурные скобки заключаются даже одиночные операторы:
```
if (x != 0) {
  y = x;
}
```
* Открывающая фигурная скобка пишется в той же строке, что и оператор.
  Ключевое слово `else` пишется после закрывающей фигурной скобки:
```
if (x != 0) {
  y = x;
} else {
  z = y;
}
```
* Данные-члены начинаются с префикса `m_`, статические данные-члены — `sm_`,
  глобальные переменные — `g_`, статические переменные (внутри функций) — `s_`.
* В операторе `switch` должны быть явным образом перечислены все допустимые
  варианты. Если переход на ветку `default:` никогда не должен происходить,
  то в ней располагается вызов макроса
  `refalrts_switch_default_violation(выражение_внутри_switch)`,
  который при передаче управления на него, выбрасывает исключение. Таким
  образом выявляются ошибки в программе, связанные с передачей неверных данных.
