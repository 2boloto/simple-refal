Основная идея — условие превращается во вспомогательную функцию, которая
проверяет, собственно, условие, и, если оно не выполняется, передаёт управление
следующим предложениям:

    F {
      . . .
      Pat1, ResC1: PatC1 = Res1;
      Pat2 = Res2;
      . . .
    }

    ↓ ↓ ↓

    F {
      . . .
      Pat1 = <F_check [перем] ResC1>;
      e.X = <F_cont e.X>;
    }

    F_check {
      [перем] PatC1 = Res1;
      [перем] e.Other = <F_cont Pat1>;
    }

    F_cont {
      Pat2 = Res2;
      . . .
    }

Здесь `F_check` — функция проверки условия, `F_cont` — функция-«континуация»,
образованная из предложений, следующих за условием. Континуация вводится
тольлко для упрощения и избежания дублирования кода. Как `[перем]` обозначен
набор переменных, присутствовавших в образце.

Интересно становится, если образец перед условием содержит открытые e-переменные.

    F {
      . . .
      PL1 e.A s.B e.C PR1, ResC1: PatC1 = Res1;
      Pat2 = Res2;
      . . .
    }

Здесь как `PL1` и `PR1` обозначены фрагменты образца, которые могут содержать
несбалансированные скобки. Также в этом примере будем полагать, что открытая
e-переменная здесь только одна. Первый шаг преобразований известен: континуация
и вызов функции проверки:

    F {
      . . .
      PL1 e.A e.C PR1 = <F_check [перем] ResC1>;
      e.X = <F_cont e.X>;
    }

    F_cont {
      Pat2 = Res2;
      . . .
    }

(Здесь мы полагаем, что открытая переменная имеет общий вид `e.A e.C`.
Вместо `e.C` здесь может находиться любой жёсткий образец.)

А что же функция проверки? С первым предложением понятно:

    F_check {
      [перем] PatC1 = Res1;
      [перем] e.Other = А тут чего?
    }

В случае фейла нужно как-то осуществить откат — попробовать новое
сопоставление:

    F_check {
      [перем] PatC1 = Res1;
      [перем] e.Other = <F_forward PL1 (e.A) e.C PR1>;
    }

    F_forward {
      PL1 (e.A_fix) t.A_next e.A_rest PR1
        = <F_next PL1 (e.A_fix t.A_next) e.A_rest PR1>;

      PL1 (e.A) e.C PR1 = <F_cont PL1 e.A e.C PR1>;
    }

    F_next {
      PL1’ (e.A_fix) e.A_var e.C PR1’ = <F_check’ [перем’] ResC1’>;
      PL1  (e.A_fix) e.A_rest    PR1  = <F_cont PL1 e.A_fix e.A_rest PR1>;
    }

Функция `F_forward` осуществляет продвижение открытой e-переменной на один терм
вперёд. Если это не удаётся, то восстанавливается аргумент функции и управление
передаётся на континуацию.

Функция `F_next` осуществляет сопоставление с уже «продвинутой» открытой
переменной. Вместо `e.A`, которая была в исходной программе, здесь фигурируют
две переменные — фиксированная `e.A_fix` и переменная `e.A_var`. Апострофы
в частях `PL1’`, `PR1’`, `ResC1’` символизируют выполненную подстановку
`e.A → e.A_fix e.A_var`, `F_check’` и `перем’` — функция проверки и набор
переменных, учитывающих разбитость `e.A`:

    F_check’ {
      [перем’] PatC1’ = Res1’;
      [перем’] e.Other = <F_forward PL1’ (e.A_fix e.A_var) PR1’>;
    }

Апострофы в `PatC1’` и `Res1’` имеют тот же смысл, что и раньше. Можно заметить,
что `F_check` эквивалентна `F_check’`, и поэтому может быть заменена ею: вместо
первой можно сразу вызывать вторую, передавая в качестве значения `e.A_fix`
пустое выражение.
