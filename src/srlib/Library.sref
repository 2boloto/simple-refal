%%
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vector>

//FROM refalrts

namespace {

static refalrts::Iter next(refalrts::Iter current) {
  return current->next;
}

static refalrts::Iter prev(refalrts::Iter current) {
  return current->prev;
}

} // unnamed namespace

//------------------------------------------------------------------------------

// Операции распределителя памяти

namespace refalrts{

namespace allocator {

bool alloc_node(Iter& node);

Iter free_ptr();

} // namespace allocator

} // namespace refalrts
%%

//==============================================================================
// Библиотека "встроенных" функций
//==============================================================================

// Основные перечисления

%%
#define USE_IDENT(ident_name) \
  (& ident_ ## ident_name<int>::name)
%%

$LABEL Success;
$LABEL Fails;
$LABEL True;
$LABEL False;
$LABEL TypeNumber;
$LABEL TypeCharacter;
$LABEL TypeFunction;
$LABEL TypeFile;
$LABEL TypeIdentifier;

// Математические операции

%%
#define ARITHM(op, check) \
  refalrts::Iter pX = 0, pY = 0; \
  refalrts::Iter pFunc = refalrts::call_left(pX, pY, arg_begin, arg_end); \
  \
  if ( \
    pX->next != pY \
    || refalrts::cDataNumber != pX->tag \
    || refalrts::cDataNumber != pY->tag \
  ) { \
    return refalrts::cRecognitionImpossible; \
  } \
  \
  check \
  \
  pX->number_info op##= pY->number_info; \
  \
  refalrts::splice_to_freelist(arg_begin, pFunc); \
  refalrts::splice_to_freelist(pY, arg_end); \
  return refalrts::cSuccess;

#define ARITHM_NO_CHECK \
  /* пусто */

#define ARITHM_ZERODIV \
  if (0 == pY->number_info) { \
    /* деление на нуль */ \
    return refalrts::cRecognitionImpossible; \
  }

%%

$ENTRY Add {
%%
  ARITHM(+, ARITHM_NO_CHECK);
%%
}

$ENTRY Sub {
%%
  ARITHM(-, ARITHM_NO_CHECK);
%%
}

$ENTRY Mul {
%%
  ARITHM(*, ARITHM_NO_CHECK);
%%
}

$ENTRY Div {
%%
  ARITHM(/, ARITHM_ZERODIV);
%%
}

$ENTRY Mod {
%%
  ARITHM(%, ARITHM_ZERODIV);
%%
}

// Ввод-вывод

%%
refalrts::FnResult write_to_stream(
  FILE *out, refalrts::Iter str_begin, refalrts::Iter str_end
) {
  if (ferror(out)) {
    return refalrts::cRecognitionImpossible;
  }

  int printf_res;

  for (
    refalrts::Iter p = str_begin;
    ! refalrts::empty_seq(p, str_end);
    refalrts::move_left(p, str_end)
  ) {
    switch(p->tag) {
      case refalrts::cDataChar: {
        printf_res = fprintf(out, "%c", p->char_info);
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataNumber: {
        printf_res = fprintf(out, "%lu ", p->number_info);
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataFunction: {
        printf_res = fprintf(out, "%s ", p->function_info->name);
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataIdentifier: {
        printf_res = fprintf(out, "%s ", (p->ident_info)());
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataOpenADT: {
        printf_res = fprintf(out, "[");
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataCloseADT: {
        printf_res = fprintf(out, "]");
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataOpenBracket: {
        printf_res = fprintf(out, "(");
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataCloseBracket: {
        printf_res = fprintf(out, ")");
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataFile: {
        printf_res = fprintf(out, "*%p", p->file_info);
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataClosure: {
        printf_res = fprintf(out, "{ ");
        p = refalrts::unwrap_closure(p);
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataClosureHead: {
        printf_res = fprintf(out, "[%lu] ", p->number_info);
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      case refalrts::cDataUnwrappedClosure: {
        printf_res = fprintf(out, "} ");
        refalrts::wrap_closure(p);
        if (printf_res < 0) {
          return refalrts::cRecognitionImpossible;
        } else {
          break;
        }
      }

      default:
        refalrts_switch_default_violation(p->tag);
        // break;
    }
  }

  printf_res = fprintf(out, "\n");
  if (printf_res < 0) {
    return refalrts::cRecognitionImpossible;
  } else {
    return refalrts::cSuccess;
  }
}
%%

$ENTRY WriteLine {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter content_b;
  refalrts::Iter content_e;
  content_b = bb_0;
  refalrts::use(content_b);
  content_e = be_0;
  refalrts::use(content_e);

  refalrts::FnResult fnres = write_to_stream(stdout, content_b, content_e);
  if (fnres != refalrts::cSuccess) {
    return fnres;
  }

  refalrts::reset_allocator();
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return fnres;
%%
}

$ENTRY FWriteLine {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter pfile_handle;
  refalrts::Iter content_b;
  refalrts::Iter content_e;
  // s.FileHandle e.Line
  if (! refalrts::svar_left(pfile_handle, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (pfile_handle->tag != refalrts::cDataFile) {
    return refalrts::cRecognitionImpossible;
  }
  content_b = bb_0;
  refalrts::use(content_b);
  content_e = be_0;
  refalrts::use(content_e);

  FILE *handle = static_cast<FILE*>(pfile_handle->file_info);
  refalrts::FnResult fnres = write_to_stream(handle, content_b, content_e);
  if (fnres != refalrts::cSuccess) {
    return fnres;
  }

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;
  refalrts::splice_stvar(res, pfile_handle);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

%%
refalrts::FnResult read_from_stream(
  FILE *input, refalrts::Iter& begin, refalrts::Iter& end
) {
  refalrts::Iter before_begin =
    prev(refalrts::allocator::free_ptr());
  refalrts::Iter cur_char_node = 0;

  int cur_char;

  for (;;) {
    cur_char = getc(input);
    if (EOF == cur_char) {
      if (! refalrts::alloc_number(cur_char_node, 0UL)) {
        return refalrts::cNoMemory;
      }
      break;
    } else if ('\n' == cur_char) {
      break;
    } else {
      /*
        Пользуемся тем фактом, что в данной реализации размещёные в свободной
        памяти узлы располагаются в последовательных адресах, которые будут
        начинаться с before_begin->next.
      */
      if (! refalrts::alloc_char(cur_char_node, static_cast<char>(cur_char))) {
        return refalrts::cNoMemory;
      }
    }
  }

  if (cur_char_node != 0) {
    begin = next(before_begin);
    end = cur_char_node;
  } else {
    begin = 0;
    end = 0;
  }

  return refalrts::cSuccess;
}
%%

$ENTRY ReadLine {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  if (! refalrts::empty_seq(bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();

  refalrts::Iter str_begin, str_end;
  refalrts::FnResult fn_result = read_from_stream(stdin, str_begin, str_end);
  if (fn_result != refalrts::cSuccess) {
    return fn_result;
  }

  refalrts::splice_evar(arg_begin, str_begin, str_end);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

$ENTRY FReadLine {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter pfile_handle;
  // s.FileHandle
  if (! refalrts::svar_left(pfile_handle, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (pfile_handle->tag != refalrts::cDataFile) {
    return refalrts::cRecognitionImpossible;
  }
  if (! refalrts::empty_seq(bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;

  FILE *handle = static_cast<FILE*>(pfile_handle->file_info);
  refalrts::Iter str_begin, str_end;
  refalrts::FnResult fn_result = read_from_stream(handle, str_begin, str_end);

  if (fn_result != refalrts::cSuccess) {
    return fn_result;
  }

  res = refalrts::splice_evar(res, str_begin, str_end);
  res = refalrts::splice_stvar(res, pfile_handle);
  refalrts::use(res);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

%%
namespace {

refalrts::FnResult string_from_seq(
  std::vector<char>& string, refalrts::Iter begin, refalrts::Iter end
) {
  std::vector<char> result;

  enum { cBufLen = 100 };
  char buffer[cBufLen + 1] = { 0 };

  for ( ; ; ) {
    unsigned read = refalrts::read_chars(buffer, cBufLen, begin, end);

    if (read == 0) {
      break;
    }

    // В текущей версии Open Watcom (и форка Open Watcom V2) есть ошибка
    // в функции vector::insert, которая возникает в случае,
    // если во время вставки вектор увеличивает свою ёмкость (capacity).
    // Для обхода этой ошибки предварительно резервируем место.
    result.reserve(result.size() + read + 1);
    result.insert(result.end(), buffer, buffer + read);
  }

  /*
    Здесь refalrts::empty_seq(begin, end) || (begin->tag != cDataChar).
  */

  if (refalrts::empty_seq(begin, end)) {
    result.push_back('\0');
    string.swap(result);
    return refalrts::cSuccess;
  } else {
    // здесь begin->tag != cDataChar
    return refalrts::cRecognitionImpossible;
  }
}

} // unnamed namespace
%%

$ENTRY FOpen {
%%
  refalrts::Iter content_b = arg_begin;
  refalrts::Iter content_e = arg_end;
  refalrts::move_left(content_b, content_e);
  refalrts::move_left(content_b, content_e);
  refalrts::move_right(content_b, content_e);

  const char *mode;

  if (refalrts::char_left('r', content_b, content_e)) {
    mode = "r";
  } else if (refalrts::char_left('w', content_b, content_e)) {
    mode = "w";
  } else {
    return refalrts::cRecognitionImpossible;
  }

  std::vector<char> filename;

  refalrts::FnResult fname_read =
    string_from_seq(filename, content_b, content_e);

  if (refalrts::cSuccess != fname_read) {
    return fname_read;
  }

  if (filename.empty()) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;

  refalrts::Iter file_ptr = 0;
  if (! refalrts::allocator::alloc_node(file_ptr)) {
    return refalrts::cNoMemory;
  }

  file_ptr->tag = refalrts::cDataFile;

  if (FILE *f = fopen(&filename[0], mode)) {
    file_ptr->file_info = f;
  } else {
    return refalrts::cRecognitionImpossible;
  }

  res = refalrts::splice_elem(res, file_ptr);
  refalrts::use(res);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

$ENTRY FClose {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter pfile_handle;
  // s.FileHandle
  if (! refalrts::svar_left(pfile_handle, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (pfile_handle->tag != refalrts::cDataFile) {
    return refalrts::cRecognitionImpossible;
  }
  if (! refalrts::empty_seq(bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = static_cast<FILE*>(pfile_handle->file_info);
  if (EOF == fclose(handle)) {
    return refalrts::cRecognitionImpossible;
  } else {
    /* Ничего не делаем */;
  }

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;
  refalrts::use(res);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

/*
  Глобальные переменные, хранящие параметры вызова
  (устанавливаются в refalrts.cpp).
*/

%%
extern char **g_argv;
extern int g_argc;
%%

$ENTRY Arg {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter pparam_no;
  // s.ParamNumber
  if (! refalrts::svar_left(pparam_no, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (pparam_no->tag != refalrts::cDataNumber) {
    return refalrts::cRecognitionImpossible;
  }
  if (! refalrts::empty_seq(bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();

  int arg_number = pparam_no->number_info;

  refalrts::Iter res_begin = 0;
  refalrts::Iter res_end = 0;

  if (arg_number < g_argc) {
    if (! refalrts::alloc_string(res_begin, res_end, g_argv[arg_number])) {
      return refalrts::cNoMemory;
    }

    refalrts::splice_evar(arg_begin, res_begin, res_end);
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

$ENTRY ExistFile {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter eFileName_b_1;
  refalrts::Iter eFileName_e_1;
  // e.FileName
  eFileName_b_1 = bb_0;
  refalrts::use(eFileName_b_1);
  eFileName_e_1 = be_0;
  refalrts::use(eFileName_e_1);

  std::vector<char> fname;

  refalrts::FnResult fname_res =
    string_from_seq(fname, eFileName_b_1, eFileName_e_1);

  if (fname_res != refalrts::cSuccess) {
    return fname_res;
  }

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;

  refalrts::Iter ans = 0;
  if (FILE *f = fopen(&fname[0], "r")) {
    // Файл существует
    fclose(f);

    if (! refalrts::alloc_ident(ans, USE_IDENT(True))) {
      return refalrts::cNoMemory;
    }
  } else {
    // Файл по-видимому не существует
    if (! refalrts::alloc_ident(ans, USE_IDENT(False))) {
      return refalrts::cNoMemory;
    }
  }

  res = refalrts::splice_elem(res, ans);
  refalrts::use(res);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

$ENTRY GetEnv {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);
  refalrts::Iter envname_b;
  refalrts::Iter envname_e;
  // e.EnvName
  envname_b = bb_0;
  refalrts::use(envname_b);
  envname_e = be_0;
  refalrts::use(envname_e);

  std::vector<char> envname;
  refalrts::FnResult envname_res =
    string_from_seq(envname, envname_b, envname_e);

  if (envname_res != refalrts::cSuccess) {
    return envname_res;
  }

  refalrts::reset_allocator();
  const char *envres = getenv(& envname[0]);

  if (envres != 0) {
    refalrts::Iter env_begin;
    refalrts::Iter env_end;

    if (! refalrts::alloc_string(env_begin, env_end, envres)) {
      return refalrts::cNoMemory;
    }

    refalrts::splice_evar(arg_begin, env_begin, env_end);

    //refalrts::Iter char_pos;
    //
    //for (const char *env = envres; *env != '\0'; ++ env) {
    //  if (! refalrts::alloc_char(char_pos, *env)) {
    //    return refalrts::cNoMemory;
    //  }
    //
    //  refalrts::splice_elem(res, char_pos);
    //}
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

$ENTRY Exit {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter pretcode;
  // s.Code
  if (! refalrts::svar_left(pretcode, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (pretcode->tag != refalrts::cDataNumber) {
    return refalrts::cRecognitionImpossible;
  }
  if (! refalrts::empty_seq(bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::set_return_code(pretcode->number_info);
  refalrts::reset_allocator();
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cExit;
%%
}

$ENTRY System {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter command_b;
  refalrts::Iter command_e;
  // e.Command
  command_b = bb_0;
  refalrts::use(command_b);
  command_e = be_0;
  refalrts::use(command_e);

  std::vector<char> command;

  refalrts::FnResult read_res =
    string_from_seq(command, command_b, command_e);

  if (read_res != refalrts::cSuccess) {
    return read_res;
  }

  fflush(stdout);
  fflush(stderr);

  system(&command[0]);

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;
  refalrts::use(res);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

// Работа с типами символов

$ENTRY IntFromStr {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter number_b;
  refalrts::Iter number_e;
  // e.NoNumber
  number_b = bb_0;
  refalrts::use(number_b);
  number_e = be_0;
  refalrts::use(number_e);

  bool start_is_digit =
    ! refalrts::empty_seq(number_b, number_e)
    && refalrts::cDataChar == number_b->tag
    && isdigit(number_b->char_info);

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;

  if (! start_is_digit) {
    refalrts::Iter fail_pos = 0;
    if (! refalrts::alloc_ident(fail_pos, USE_IDENT(Fails))) {
      return refalrts::cNoMemory;
    }

    res = refalrts::splice_evar(res, number_b, number_e);
    res = refalrts::splice_elem(res, fail_pos);
  } else {
    refalrts::RefalNumber acc = 0;

    for ( ; ; ) {
      if (refalrts::empty_seq(number_b, number_e)) {
        break;
      } else if (number_b->tag != refalrts::cDataChar) {
        break;
      } else if (! isdigit(number_b->char_info)) {
        break;
      } else {
        (acc *= 10) += number_b->char_info - '0';
      }

      refalrts::move_left(number_b, number_e);
    }

    refalrts::Iter success_pos = 0;
    refalrts::Iter number_pos = 0;

    if (! refalrts::alloc_ident(success_pos, USE_IDENT(Success))) {
      return refalrts::cNoMemory;
    }

    if (! refalrts::alloc_number(number_pos, acc)) {
      return refalrts::cNoMemory;
    }

    res = refalrts::splice_evar(res, number_b, number_e);
    res = refalrts::splice_elem(res, number_pos);
    res = refalrts::splice_elem(res, success_pos);
  }

  refalrts::use(res);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

$ENTRY StrFromInt {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter number;
  // s.Number
  if (! refalrts::svar_left(number, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (number->tag != refalrts::cDataNumber) {
    return refalrts::cRecognitionImpossible;
  }
  if (! refalrts::empty_seq(bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;

  refalrts::Iter char_pos = 0;
  if (refalrts::RefalNumber num = number->number_info) {
    // Длина десятичного числа = 0,3 * длина двоичного числа,
    // т.к. lg(2) = 0,3. Хрен с ним, что много. Главное, что не мало.
    enum { cMaxNumberLen = 8 * sizeof(refalrts::RefalNumber) * 3 / 10 + 2 };

    char buffer[cMaxNumberLen + 1] = { 0 };
    char *lim_digit = buffer + cMaxNumberLen;
    char *cur_digit = lim_digit;

    while (num != 0) {
      -- cur_digit;
      *cur_digit = static_cast<char>((num % 10) + '0');
      num /= 10;
    }

    refalrts::Iter num_begin;
    refalrts::Iter num_end;
    bool allocated = refalrts::alloc_chars(
      num_begin, num_end, cur_digit, unsigned(lim_digit - cur_digit)
    );

    if (! allocated) {
      return refalrts::cNoMemory;
    }

    refalrts::splice_evar(res, num_begin, num_end);
  } else {
    if (! refalrts::alloc_char(char_pos, '0')) {
      return refalrts::cNoMemory;
    }

    refalrts::splice_elem(res, char_pos);
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);

  return refalrts::cSuccess;
%%
}

$ENTRY Chr {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter number;
  // s.Code
  if (! refalrts::svar_left(number, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (number->tag != refalrts::cDataNumber) {
    return refalrts::cRecognitionImpossible;
  }
  if (! refalrts::empty_seq(bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }

  char result = static_cast<char>(number->number_info);

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;
  refalrts::Iter n0 = 0;
  if (! refalrts::alloc_char(n0, result)) {
    return refalrts::cNoMemory;
  }
  res = refalrts::splice_elem(res, n0);
  refalrts::use(res);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

$ENTRY Ord {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);

  refalrts::Iter chr;
  // s.Char
  if (! refalrts::svar_left(chr, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (chr->tag != refalrts::cDataChar) {
    return refalrts::cRecognitionImpossible;
  }
  if (! refalrts::empty_seq(bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber result = static_cast<unsigned char>(chr->char_info);

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;
  refalrts::Iter n0 = 0;
  if (! refalrts::alloc_number(n0, result)) {
    return refalrts::cNoMemory;
  }
  res = refalrts::splice_elem(res, n0);
  refalrts::use(res);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

%%
namespace {

template <typename T>
char compare_char(T x, T y) {
  if (x < y) {
    return '<';
  } else if (x == y) {
    return '=';
  } else {
    return '>';
  }
}

} // unnamed namespace
%%

$ENTRY SymbCompare {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);
  refalrts::Iter left;
  refalrts::Iter right;
  // s.Num1 s.Num2
  if (! refalrts::svar_left(left, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (! refalrts::svar_left(right, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (! refalrts::empty_seq(bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }

  char order;

  switch(left->tag) {
    case refalrts::cDataNumber:
      switch(right->tag) {
        case refalrts::cDataNumber:
          order = compare_char(left->number_info, right->number_info);
          break;

        case refalrts::cDataChar:
          order = '>';
          break;

        case refalrts::cDataFunction:
          order = '>';
          break;

        case refalrts::cDataIdentifier:
          order = '>';
          break;

        case refalrts::cDataFile:
          order = '>';
          break;

        default:
          order = '?';
          break;
      }
      break;

    case refalrts::cDataChar:
      switch(right->tag) {
        case refalrts::cDataNumber:
          order = '<';
          break;

        case refalrts::cDataChar:
          order = compare_char(left->char_info, right->char_info);
          break;

        case refalrts::cDataFunction:
          order = '>';
          break;

        case refalrts::cDataIdentifier:
          order = '>';
          break;

        case refalrts::cDataFile:
          order = '>';
          break;

        default:
          order = '?';
          break;
      }
      break;

    case refalrts::cDataFunction:
      switch(right->tag) {
        case refalrts::cDataNumber:
          order = '<';
          break;

        case refalrts::cDataChar:
          order = '<';
          break;

        case refalrts::cDataFunction:
          {
            int cmpres =
              strcmp(left->function_info->name, right->function_info->name);

            if (cmpres < 0) {
              order = '<';
            } else if (cmpres > 0) {
              order = '>';
            } else {
              order =
                compare_char(
                  left->function_info->ptr,
                  right->function_info->ptr
                );
            }
          }
          break;

        case refalrts::cDataIdentifier:
          order = '>';
          break;

        case refalrts::cDataFile:
          order = '>';
          break;

        default:
          order = '?';
          break;
      }
      break;

    case refalrts::cDataIdentifier:
      switch(right->tag) {
        case refalrts::cDataNumber:
          order = '<';
          break;

        case refalrts::cDataChar:
          order = '<';
          break;

        case refalrts::cDataFunction:
          order = '<';
          break;

        case refalrts::cDataIdentifier:
          {
            int cmpres =
              strcmp((left->ident_info)(), (right->ident_info)());
            if (cmpres < 0) {
              order = '<';
            } else if (cmpres > 0) {
              order = '>';
            } else {
              order = '=';
            }
          }
          break;

        case refalrts::cDataFile:
          order = '>';
          break;

        default:
          order = '?';
          break;
      }
      break;

    case refalrts::cDataFile:
      switch(right->tag) {
        case refalrts::cDataNumber:
          order = '<';
          break;

        case refalrts::cDataChar:
          order = '<';
          break;

        case refalrts::cDataFunction:
          order = '<';
          break;

        case refalrts::cDataIdentifier:
          order = '<';
          break;

        case refalrts::cDataFile:
          order = compare_char(left->file_info, right->file_info);
          break;

        default:
          order = '?';
          break;
      }
      break;

    default:
      order = '?';
      break;
  }

  if ('?' == order) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;
  refalrts::Iter n0 = 0;
  if (! refalrts::alloc_char(n0, order)) {
    return refalrts::cNoMemory;
  }
  res = refalrts::splice_elem(res, n0);
  refalrts::use(res);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

$ENTRY SymbType {
%%
  refalrts::Iter bb_0 = arg_begin;
  refalrts::Iter be_0 = arg_end;
  refalrts::move_left(bb_0, be_0);
  refalrts::move_left(bb_0, be_0);
  refalrts::move_right(bb_0, be_0);
  refalrts::Iter atom;
  // s.Num
  if (! refalrts::svar_left(atom, bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }
  if (! refalrts::empty_seq(bb_0, be_0)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalIdentifier type_tag = 0;

  switch(atom->tag) {
  case refalrts::cDataNumber:
    type_tag = USE_IDENT(TypeNumber);
    break;

  case refalrts::cDataChar:
    type_tag = USE_IDENT(TypeCharacter);
    break;

  case refalrts::cDataFunction:
    type_tag = USE_IDENT(TypeFunction);
    break;

  case refalrts::cDataIdentifier:
    type_tag = USE_IDENT(TypeIdentifier);
    break;

  case refalrts::cDataFile:
    type_tag = USE_IDENT(TypeFile);
    break;

  default:
    break;
  }

  if (0 == type_tag) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();
  refalrts::Iter res = arg_begin;
  refalrts::Iter n0 = 0;
  if (! refalrts::alloc_ident(n0, type_tag)) {
    return refalrts::cNoMemory;
  }
  res = refalrts::splice_elem(res, n0);
  refalrts::use(res);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}
