*$FROM Utils;
$EXTERN Builtins, Map;

/**
  <Transform t.Unit*> == t.Unit*
*/
$ENTRY Transform {
  e.Units
    = <Transform-Step
        UnCondition <Transform-Step UnBlock e.Units>
      >;
}

Transform-Step {
  s.FnMode e.Units
    = <DoTransform s.FnMode <GetFunctionNames (<Builtins>) e.Units>>;
}

GetFunctionNames {
  (e.Names) e.Units (Function t.SrcPos (e.Name) s.Scope e.Sentences)
    = <GetFunctionNames (e.Names (e.Name)) e.Units>
      (Function t.SrcPos (e.Name) s.Scope e.Sentences);

  (e.Names) e.Units (Extern e.ExternalNames)
    = <GetFunctionNames (e.Names e.ExternalNames) e.Units>
      (Extern e.ExternalNames);

  (e.Names) e.Units (SpecialComment t.SrcPos e.Text)
    = <GetFunctionNames (e.Names) e.Units>
      (SpecialComment t.SrcPos e.Text);

  (e.Names) /* пусто */ = (e.Names);
}

DoTransform {
  s.FnMode (e.Names) (Function t.SrcPos (e.Name) s.Scope e.Sentences) e.Units
    , <Mu s.FnMode (e.Names) t.SrcPos (e.Name) s.Scope e.Sentences>
    : (e.NewNames) e.NewFunctions
    = e.NewFunctions
      <DoTransform s.FnMode (e.NewNames) e.Units>;

  s.FnMode (e.Names) (Extern e.ExternNames) e.Units
    = (Extern e.ExternNames)
      <DoTransform s.FnMode (e.Names) e.Units>;

  s.FnMode (e.Names) (SpecialComment t.SrcPos e.Text) e.Units
    = (SpecialComment t.SrcPos e.Text)
      <DoTransform s.FnMode (e.Names) e.Units>;

  s.FnMode (e.Names) /* пусто */ = /* пусто */;
}

** НАМЕРЕННО ОТКАЗЫВАЕМСЯ ОТ ОТСЛЕЖИВАНИЯ КОПИРОВАНИЯ ПОВТОРНЫХ ПЕРЕМЕННЫХ

/**
  <UnBlock (e.Names) t.SrcPos (e.Name) s.Scope e.Sentences>
    == (e.NewNames) e.NewFunctions
*/
UnBlock {
  (e.Names) t.SrcPos (e.Name) s.Scope e.Sentences
    = <DoUnBlock
        (e.Names) t.SrcPos (e.Name /* — имя текущей функции */) s.Scope
        (e.Name /* — префикс */)
        (/* scanned functions */)
        (/* scanned sentences */)
        e.Sentences
        (/* unscanned functions */)
      >;
}

DoUnBlock {
  (e.Names) t.SrcPos (e.Name) s.Scope (e.Prefix)
  (e.ScannedFunctions) (e.ScannedSentences)
  e.Sentences-B (e.BlockedSentence) e.Sentences-E
  (e.UnscannedFunctions)
    , <WithBlock e.BlockedSentence>
    : (e.SentencePrefix) CALL-BLOCK (e.BlockResult) e.SubSentences
    , <NewName (e.Names) e.Prefix> : (e.RefilledNames) e.NewName
    , <BlockScopeVars e.SentencePrefix> : e.ScopeVars
    = <DoUnBlock
        (e.RefilledNames) t.SrcPos (e.Name) s.Scope (e.Prefix)
        (e.ScannedFunctions)
        (
          e.ScannedSentences
          e.Sentences-B
          (
            e.SentencePrefix
            RETURN ((Call t.SrcPos (e.NewName) e.ScopeVars e.BlockResult))
          )
        )
        e.Sentences-E
        (
          e.UnscannedFunctions
          (
            (e.NewName)
            <Map
              (transformer_AddScopeVars e.ScopeVars) e.SubSentences
            >
          )
        )
      >;

  (e.Names) t.SrcPos (e.Name) s.Scope (e.Prefix)
  (e.ScannedFunctions) (e.ScannedSentences) e.UnscannedSentences
  (e.UnscannedFunctions)
    = <DoUnBlock-NextFunction
        (e.Names) t.SrcPos (e.Prefix)
        (
          e.ScannedFunctions
          (Function
            t.SrcPos (e.Name) s.Scope e.ScannedSentences e.UnscannedSentences
          )
        )
        (e.UnscannedFunctions)
      >;
}

DoUnBlock-NextFunction {
  (e.Names) t.SrcPos (e.Prefix) (e.ScannedFunctions)
  (((e.NextFunctionName) e.NextFunctionSentences) e.UnscannedFunctions)
    = <DoUnBlock
        (e.Names) t.SrcPos (e.NextFunctionName) Local (e.Prefix)
        (e.ScannedFunctions)
        (/* scanned sentences */)
        e.NextFunctionSentences
        (e.UnscannedFunctions)
      >;

  (e.Names) t.SrcPos (e.Prefix) (e.ScannedFunctions) (/* пусто */)
    = (e.Names) e.ScannedFunctions;
}

WithBlock {
  (e.Pattern) e.Sentence = <DoWithBlock ((e.Pattern)) e.Sentence>;
}

DoWithBlock {
  (e.Prefix) (Condition t.CondResult t.CondPattern) e.Tail
    = <DoWithBlock (e.Prefix (Condition t.CondResult t.CondPattern)) e.Tail>;

  (e.Prefix) CALL-BLOCK t.Result e.SubSentences
    = (e.Prefix) CALL-BLOCK t.Result e.SubSentences;

  (e.Prefix) RETURN t.Result
    = /* пусто */;
}

BlockScopeVars {
  (e.Pattern) e.Conditions
    = <Map
        transformer_MakeVariables
        <ExtractVariables ((e.Pattern) e.Conditions RETURN ())>
      >;
}

$ENTRY transformer_MakeVariables {
  ('e' e.Index) = (Brackets (Variable NO-POS 'e' e.Index));
  (s.VarType e.Index) = (Variable NO-POS s.VarType e.Index);
}

$ENTRY transformer_AddScopeVars {
  e.ScopeVars ((e.Pattern) e.Tail) = ((e.ScopeVars e.Pattern) e.Tail);
}


/**
  <UnCondition (e.Names) t.SrcPos (e.Name) s.Scope e.Sentences>
    == (e.NewNames) e.NewFunctions
*/
UnCondition {
  (e.Names) t.SrcPos (e.Name) s.Scope e.Sentences
    = <DoUnCondition
        (e.Names) t.SrcPos (e.Name /* — имя текущей функции */) s.Scope
        (e.Name /* — префикс */)
        (/* scanned functions */)
        e.Sentences
        (/* unscanned functions */)
      >;
}

DoUnCondition {
  (e.Names) t.SrcPos (e.Name) s.Scope (e.Prefix)
  (e.ScannedFunctions)
  e.Sentences-B (e.ConditionalSentence) e.Sentences-E
  (e.UnscannedFunctions)
    , <UnConditionSentence
        (e.Names) (e.Prefix) (e.ConditionalSentence) e.Sentences-E
      >
    : Success (e.RefilledNames) (e.TransformedSentences) e.NewFunctions
    = <DoUnCondition-NextFunction
        (e.RefilledNames) t.SrcPos (e.Prefix)
        (
          e.ScannedFunctions
          (Function
            t.SrcPos (e.Name) s.Scope
            e.Sentences-B
            e.TransformedSentences
          )
        )
        (e.UnscannedFunctions e.NewFunctions)
      >;

  (e.Names) t.SrcPos (e.Name) s.Scope (e.Prefix)
  (e.ScannedFunctions) e.Sentences (e.UnscannedFunctions)
    = <DoUnCondition-NextFunction
        (e.Names) t.SrcPos (e.Prefix)
        (
          e.ScannedFunctions
          (Function t.SrcPos (e.Name) s.Scope e.Sentences)
        )
        (e.UnscannedFunctions)
      >;
}

DoUnCondition-NextFunction {
  (e.Names) t.SrcPos (e.Prefix) (e.ScannedFunctions)
  (((e.NextFunctionName) e.NextFunctionSentences) e.UnscannedFunctions)
    = <DoUnCondition
        (e.Names) t.SrcPos (e.NextFunctionName) Local (e.Prefix)
        (e.ScannedFunctions)
        e.NextFunctionSentences
        (e.UnscannedFunctions)
      >;

  (e.Names) t.SrcPos (e.Prefix) (e.ScannedFunctions) (/* пусто */)
    = (e.Names) e.ScannedFunctions
}

/**
  <UnConditionSentence
    (e.Names) (e.Prefix) (e.ConditionalSentence) e.ContinuationSentences
  >
    == Success (e.RefilledNames) (e.TransformedSentences) e.NewFunctions
    == Fails
*/
UnConditionSentence {
  (e.Names) (e.Prefix) (e.Sentence) e.ContinuationSentences
    , e.Sentence
    : {
        (e.Pattern) (Condition t.CondResult t.CondPattern) e.Tail
          , <AnalyzeContinuation (e.Names) (e.Prefix) e.ContinuationSentences>
          : (e.RefilledNames1) t.ContName e.ContFunction
          , <NewName (e.RefilledNames1) e.Prefix '_DEBUG'>
          : (e.RefilledNames) e.DebugFunction
          , <ExtractVariables (e.Sentence)> : e.Variables
          = Success
            (e.RefilledNames)
            (
              (e.Sentence)
              <MakeContinuationSentence t.ContName>
            )
            (
              (e.DebugFunction)
              <DebugPrintMatchTemplates
                <PatternSteps (e.Variables) e.Pattern>
              >
            )
            e.ContFunction;

        (e.Pattern) RETURN (e.Result) = Fails;
      };
}

AnalyzeContinuation {
  (e.Names) (e.Prefix) /* пусто */ = (e.Names) NoContinuation /* пусто */;

  (e.Names) (e.Prefix) e.Sentences
    , <NewName (e.Names) e.Prefix '_cont'> : (e.RefilledNames) e.ContName
    = (e.RefilledNames)
      (e.ContName)
      ((e.ContName) e.Sentences);
}

MakeContinuationSentence {
  NoContinuation = /* пусто */;
  (e.ContName)
    = (
        ((Variable NO-POS 'eOther'))
        RETURN
        ((Call NO-POS (e.ContName) (Variable NO-POS 'eOther')))
      );
}

DebugPrintMatchTemplates {
  e.Templates ((e.T1) (e.T2) (e.T3) (e.T4) (e.T5) (e.T5-sub) (e.T6) (e.T7))
    = <DebugPrintMatchTemplates e.Templates>
      ((e.T1) RETURN ((Compound 'T1')))
      ((e.T2) RETURN ((Compound 'T2')))
      ((e.T3) RETURN ((Compound 'T3')))
      ((e.T4) RETURN ((Compound 'T4')))
      ((e.T5) RETURN ((Compound 'T5')))
      ((e.T5-sub) RETURN ((Compound 'T5 substitute')))
      ((e.T6) RETURN ((Compound 'T6')))
      ((e.T7) RETURN ((Compound 'T7')));

  ((e.T0))
    = ((e.T0) RETURN ((Compound 'T0')));
}

PatternSteps {
  (e.UsedVariables) e.Pattern
    = <Open 'a' 5 'log.txt'>
      <DoPatternSteps
        (e.UsedVariables) (/* bound variables */) (HOLE e.Pattern)
      >;
}

DoPatternSteps {
  t.UsedVariables (e.BoundEVariables) e.HolesAndItems
    , e.HolesAndItems
    : {
        /* Жёсткие элементы */
        e.HolesAndItems-B (HOLE t.Item e.Pattern) e.HolesAndItems-E
          , <HardItem (e.BoundEVariables) t.Item> : True
          = <DoPatternSteps
              t.UsedVariables (e.BoundEVariables)
              e.HolesAndItems-B t.Item (HOLE e.Pattern) e.HolesAndItems-E
            >;

        e.HolesAndItems-B (HOLE e.Pattern t.Item) e.HolesAndItems-E
          , <HardItem (e.BoundEVariables) t.Item> : True
          = <DoPatternSteps
              t.UsedVariables (e.BoundEVariables)
              e.HolesAndItems-B (HOLE e.Pattern) t.Item e.HolesAndItems-E
            >;

        /* Закрытая e-переменная */
        e.HolesAndItems-B
        (HOLE (Variable t.SrcPos 'e' e.Index))
        e.HolesAndItems-E
          = <DoPatternSteps
              t.UsedVariables (e.BoundEVariables (e.Index))
              e.HolesAndItems-B
              (Variable t.SrcPos 'e' e.Index)
              e.HolesAndItems-E
            >;

         /* Пустая дырка */
         e.HolesAndItems-B (HOLE /* пусто */) e.HolesAndItems-E
           = <DoPatternSteps
               t.UsedVariables (e.BoundEVariables)
               e.HolesAndItems-B e.HolesAndItems-E
             >;

         /* Скобки */
         e.HolesAndItems-B
         (HOLE (Brackets e.InBrackets) e.Pattern)
         e.HolesAndItems-E
           = <DoPatternSteps
               t.UsedVariables (e.BoundEVariables)
               e.HolesAndItems-B
               (LeftBracket)
               (HOLE e.InBrackets)
               (RightBracket)
               (HOLE e.Pattern)
               e.HolesAndItems-E
             >;

         e.HolesAndItems-B
         (HOLE e.Pattern (Brackets e.InBrackets))
         e.HolesAndItems-E
           = <DoPatternSteps
               t.UsedVariables (e.BoundEVariables)
               e.HolesAndItems-B
               (HOLE e.Pattern)
               (LeftBracket)
               (HOLE e.InBrackets)
               (RightBracket)
               e.HolesAndItems-E
             >;

         /* Открытая e-переменная */
         e.HolesAndItems-B
         (HOLE (Variable t.SrcPos 'e' e.Index) e.Pattern)
         e.HolesAndItems-E
           = <DoPatternSteps
               t.UsedVariables (e.BoundEVariables (e.Index))
               e.HolesAndItems-B
               (OpenE t.SrcPos 'e' e.Index)
               (HOLE e.Pattern)
               e.HolesAndItems-E
             >
             (
               <Map
                 transformer_BindBrackets
                 <T1 t.UsedVariables e.HolesAndItems>
                 <T2 t.UsedVariables e.HolesAndItems>
                 <T3 t.UsedVariables e.HolesAndItems>
                 <T4 t.UsedVariables e.HolesAndItems>
                 <T5 t.UsedVariables e.HolesAndItems>
                 <T5-sub t.UsedVariables t.SrcPos e.Index>
                 <T6 t.UsedVariables e.HolesAndItems>
                 <T7 t.UsedVariables e.HolesAndItems>
               >
             );

           /* Конец разбора */
           e.OnlyItems
             = (<transformer_BindBrackets <T0 e.OnlyItems>>);
      };
}

HardItem {
  (e.BoundEVariables) (Compound e.Compound) = True;
  (e.BoundEVariables) (Number s.Number) = True;
  (e.BoundEVariables) (Char s.Char) = True;

  (e.BoundEVariables) (Variable t.SrcPos 's' e.Index) = True;
  (e.BoundEVariables) (Variable t.SrcPos 't' e.Index) = True;

  (e.BoundEVariables-B (e.Index) e.BoundEVariables-E)
  (Variable t.SrcPos 'e' e.Index) = True;

  (e.BoundEVariables) (Variable t.SrcPos 'e' e.Index) = False;
  (e.BoundEVariables) (Brackets e.Pattern) = False;
}

$ENTRY transformer_BindBrackets {
  (e.Expr) = (<DoBindBrackets ('$') e.Expr>);
}

DoBindBrackets {
  (t.MultiBracket e.Scanned) t.Symbol e.Tail
    , <Symbol t.Symbol> : True
    = <DoBindBrackets (t.MultiBracket e.Scanned t.Symbol) e.Tail>;

  (t.MultiBracket e.Scanned) (Variable t.SrcPos s.Type e.Index) e.Tail
    = <DoBindBrackets
        (t.MultiBracket e.Scanned (Variable t.SrcPos s.Type e.Index)) e.Tail
      >;

  (t.MultiBracket e.Scanned) (OpenE t.SrcPos s.Type e.Index) e.Tail
    = <DoBindBrackets
        (t.MultiBracket e.Scanned (Brackets (Variable t.SrcPos s.Type e.Index)))
        e.Tail
      >;

  (t.MultiBracket e.Scanned) (Brackets e.InBrackets) e.Tail
    = <DoBindBrackets
        (t.MultiBracket e.Scanned (Brackets e.InBrackets)) e.Tail
      >;

  (t.MultiBracket e.Scanned) (LeftBracket) e.Tail
    = <DoBindBrackets ((t.MultiBracket e.Scanned)) e.Tail>;

  ((t.MultiBracket e.Scanned) e.InBrackets) (RightBracket) e.Tail
    = <DoBindBrackets
        (t.MultiBracket e.Scanned (Brackets e.InBrackets)) e.Tail
      >;

  ('$' e.Scanned) = e.Scanned;
}

/*
  Смысл функций T1…T7 поясняется в «Подход к преобразованию условий.md».
*/

T1 {
  t.UsedVars
  e.Items (HOLE (Variable t.SrcPos 'e' e.Index) e.Pattern) e.ItemsAndHoles
    , <NewName t.UsedVars 'e' e.Index '_fix'> : t.UsedVars1 e.eX_fix
    , <NewName t.UsedVars1 't' e.Index '_next'> : t.UsedVars2 e.tX_next
    , <NewName t.UsedVars2 'e' e.Index '_rest'> : t.UsedVars3 e.eX_rest
    = (
        e.Items
        (Brackets (Variable t.SrcPos e.eX_fix))
        (Variable t.SrcPos e.tX_next)
        (Variable t.SrcPos e.eX_rest)
        <PassiveHoles t.UsedVars3 e.ItemsAndHoles>
      );
}

PassiveHoles {
  t.UsedVariables
  e.Items (HOLE (Variable t.SrcPos 'e' e.Index) e.Pattern)
  e.ItemsAndHoles
    , <NewName t.UsedVariables 'e' e.Index '_rest'> : t.NewVars e.eX_rest
    = e.Items
      (Variable t.SrcPos e.eX_rest)
      <PassiveHoles t.NewVars e.ItemsAndHoles>;

  t.UsedVariables e.Items = e.Items;
}

T2 {
  t.UsedVars
  e.Items (HOLE (Variable t.SrcPos 'e' e.Index) e.Pattern) e.ItemsAndHoles
    , <NewName t.UsedVars 'e' e.Index '_fix'> : t.UsedVars1 e.eX_fix
    , <NewName t.UsedVars1 't' e.Index '_next'> : t.UsedVars2 e.tX_next
    , <NewName t.UsedVars2 'e' e.Index '_rest'> : t.UsedVars3 e.eX_rest
    = (
        e.Items
        (Brackets (Variable t.SrcPos e.eX_fix) (Variable t.SrcPos e.tX_next))
        (Variable t.SrcPos e.eX_rest)
        <PassiveHoles t.UsedVars3 e.ItemsAndHoles>
      );
}

T3 {
  t.UsedVars
  e.Items (HOLE (Variable t.SrcPos 'e' e.Index) e.Pattern) e.ItemsAndHoles
    , <NewName t.UsedVars 'e' e.Index '_fix'> : t.UsedVars1 e.eX_fix
    = (
        e.Items
        (Brackets (Variable t.SrcPos e.eX_fix))
        <PassiveHoles t.UsedVars1 e.ItemsAndHoles>
      );
}

T4 {
  t.UsedVars
  e.Items (HOLE (Variable t.SrcPos 'e' e.Index) e.Pattern) e.ItemsAndHoles
    , <NewName t.UsedVars 'e' e.Index '_fix'> : t.UsedVars1 e.eX_fix
    = (
        e.Items (Variable t.SrcPos e.eX_fix)
        <PassiveHoles t.UsedVars1 e.ItemsAndHoles>
      );
}

T5 {
  t.UsedVars
  e.Items (HOLE (Variable t.SrcPos 'e' e.Index) e.Pattern) e.ItemsAndHoles
    , <T5-sub t.UsedVars t.SrcPos e.Index>
    : (t.SourceVar t.eX_fix t.eX_var)
    = (
        e.Items (Brackets t.eX_fix) t.eX_var
        <Substitute
          e.Pattern <T5-UnHole e.ItemsAndHoles> (t.SourceVar t.eX_fix t.eX_var)
        >
      );
}

T5-UnHole {
  e.Items (HOLE e.Pattern) e.ItemsAndHoles
    = e.Items e.Pattern <T5-UnHole e.ItemsAndHoles>;

  e.Items = e.Items;
}

T5-sub {
  t.UsedVars t.SrcPos e.Index
    , <NewName t.UsedVars 'e' e.Index '_fix'> : t.UsedVars1 e.eX_fix
    , <NewName t.UsedVars 'e' e.Index '_var'> : t.UsedVars2 e.eX_var
    = (
        (Variable t.SrcPos 'e' e.Index)
        (Variable t.SrcPos e.eX_fix)
        (Variable t.SrcPos e.eX_var)
      );
}

Substitute {
  (Variable t.SrcPos1 s.Type e.Index) e.Tail
  ((Variable t.SrcPos2 s.Type e.Index) e.Expr)
    = e.Expr
      <Substitute e.Tail ((Variable t.SrcPos2 s.Type e.Index) e.Expr)>;

  (Brackets e.InBrackets) e.Tail (t.Variable e.Expr)
    = (Brackets <Substitute e.InBrackets (t.Variable e.Expr)>)
      <Substitute e.Tail (t.Variable e.Expr)>;

  t.OtherItem e.Tail (t.Variable e.Expr)
    = t.OtherItem <Substitute e.Tail (t.Variable e.Expr)>;

  /* пусто */ (t.Variable e.Expr)
    = /* пусто */;
}

T6 {
  t.UsedVars
  e.Items (HOLE (Variable t.SrcPos 'e' e.Index) e.Pattern) e.ItemsAndHoles
    , <NewName t.UsedVars 'e' e.Index '_fix'> : t.UsedVars1 e.eX_fix
    , <NewName t.UsedVars1 'e' e.Index '_rest'> : t.UsedVars2 e.eX_rest
    = (
        e.Items
        (Brackets (Variable t.SrcPos e.eX_fix))
        (Variable t.SrcPos e.eX_rest)
        <PassiveHoles t.UsedVars2 e.ItemsAndHoles>
      );
}

T7 {
  t.UsedVars
  e.Items (HOLE (Variable t.SrcPos 'e' e.Index) e.Pattern) e.ItemsAndHoles
    , <NewName t.UsedVars 'e' e.Index '_fix'> : t.UsedVars1 e.eX_fix
    , <NewName t.UsedVars1 'e' e.Index '_rest'> : t.UsedVars2 e.eX_rest
    = (
        e.Items
        (Variable t.SrcPos e.eX_fix) (Variable t.SrcPos e.eX_rest)
        <PassiveHoles t.UsedVars2 e.ItemsAndHoles>
      );
}

T0 {
  e.Items = (<DoT0 e.Items>);
}

DoT0 {
  (OpenE t.SrcPos 'e' e.Index) e.Tail
    = (Brackets (Variable t.SrcPos 'e' e.Index)) <DoT0 e.Tail>;

  (Brackets e.InBrackets) e.Tail = (Brackets <DoT0 e.InBrackets>) <DoT0 e.Tail>;

  t.OtherItem e.Tail = t.OtherItem <DoT0 e.Tail>;

  /* пусто */ = /* пусто */;
}


Function {
  (e.Names) t.SrcPos (e.Name) s.Scope e.Sentences
    = <ScanFunction
        (e.Names)
        t.SrcPos (e.Name /* — имя текущей функции */) s.Scope
        (e.Name /* — префикс */)
        (/* scanned functions */)
        (/* scanned sentences */)
        e.Sentences
        (/* unscanned functions */)
      >;
}

*$FROM Utils
$EXTERN Unique;

ExtractVariables {
  e.Sentences = <Unique <ExtractVariables-Sentences e.Sentences>>;
}

ExtractVariables-Sentences {
  ((e.Pattern) e.Tail) e.Sentences
    = <ExtractVariables-Expr e.Pattern>
      <ExtractVariables-Tail e.Tail>
      <ExtractVariables-Sentences e.Sentences>;

  /* пусто */ = /* пусто */;
}

ExtractVariables-Tail {
  (Condition (e.Result) (e.Pattern)) e.Tail
    = <ExtractVariables-Expr e.Result>
      <ExtractVariables-Expr e.Pattern>
      <ExtractVariables-Tail e.Tail>;

  RETURN (e.Result) = <ExtractVariables-Expr e.Result>;

  CALL-BLOCK (e.Result) e.Sentences
    = <ExtractVariables-Expr e.Result>
      <ExtractVariables-Sentences e.Sentences>;
}

ExtractVariables-Expr {
  (Variable t.SrcPos s.VarType e.Index) e.Terms
    = (s.VarType e.Index) <ExtractVariables-Expr e.Terms>;

  (Brackets e.Inner) e.Terms = <ExtractVariables-Expr e.Inner e.Terms>;
  (Call t.SrcPos (e.Function) e.Inner) e.Terms
    = <ExtractVariables-Expr e.Inner e.Terms>;

  t.Other e.Terms = <ExtractVariables-Expr e.Terms>;

  /* пусто */ = /* пусто */;
}


ScanFunction {
  t.Names t.SrcPos (e.Name) s.Scope (e.Prefix)
  (e.ScannedFunctions) (e.ScannedSentences)
  t.NextSentence e.Sentences (e.UnscannedFunctions)
    , t.NextSentence
    : {
        (t.Pattern (Condition t.CondResult t.CondPattern) e.Tail)
          = <ScanFunction-Condition
              t.Names (<ExtractVariables t.NextSentence>)
              t.SrcPos (e.Name) s.Scope (e.Prefix)
              (e.ScannedFunctions) (e.ScannedSentences)
              t.NextSentence e.Sentences (e.UnscannedFunctions)
            >;

         (t.Pattern CALL-BLOCK t.Result e.SubSentences)
           = <ScanFunction-Block
               t.Names t.SrcPos (e.Name) s.Scope (e.Prefix)
               (e.ScannedFunctions) (e.ScannedSentences)
               t.NextSentence e.Sentences (e.UnscannedFunctions)
             >;

         (t.Pattern RETURN t.Result)
           = <ScanFunction
               t.Names t.SrcPos (e.Name) s.Scope (e.Prefix)
               (e.ScannedFunctions) (e.ScannedSentences t.NextSentence)
               e.Sentences (e.UnscannedFunctions)
             >;
      };

    t.Names t.SrcPos (e.Name) s.Scope (e.Prefix)
    (e.ScannedFunctions) (e.ScannedSentences)
    /* кончились предложения текущей функции */
    (((e.NextName) e.NextSentences) e.UnscannedFunctions)
      = <ScanFunction
          t.Names t.SrcPos (e.NextName) Local (e.Prefix)
          (
            e.ScannedFunctions
            (Function t.SrcPos (e.Name) s.Scope e.ScannedSentences)
          )
          (/* scanned sentences */)
          e.NextSentences (e.UnscannedFunctions)
        >;

    t.Names t.SrcPos (e.Name) s.Scope (e.Prefix)
    (e.ScannedFunctions) (e.ScannedSentences)
    /* кончились предложения текущей функции */
    (/* кончились непросканированные функции */)
      = t.Names
        e.ScannedFunctions
        (Function t.SrcPos (e.Name) s.Scope e.ScannedSentences);
}

ScanFunction-Condition {
  t.Names t.Variables t.SrcPos (e.Name) s.Scope (e.Prefix)
  (e.ScannedFunctions) (e.ScannedSentences)
  t.NextSentence /* последнее */ (e.UnscannedFunctions)
    = <ScanFunction-Condition-Aux
        t.Names t.Variables t.SrcPos (e.Name) s.Scope (e.Prefix)
        (e.ScannedFunctions) (e.ScannedSentences)
        t.NextSentence LAST-SENTENCE (e.UnscannedFunctions)
      >;

  t.Names t.Variables t.SrcPos (e.Name) s.Scope (e.Prefix)
  (e.ScannedFunctions) (e.ScannedSentences)
  t.NextSentence e.Sentences (e.UnscannedFunctions)
    , <NewName t.Names e.Prefix>: t.RefilledNames e.NewName
    = <ScanFunction-Condition-Aux
        t.RefilledNames t.Variables t.SrcPos (e.Name) s.Scope (e.Prefix)
        (e.ScannedFunctions) (e.ScannedSentences)
        t.NextSentence (e.NewName)
        (((e.NewName) e.Sentences) e.UnscannedFunctions)
      >;
}

NewName {
  (e.Names-B (e.Prefix) e.Names-E) e.Prefix
    = <DoNewName ((e.Prefix) e.Names-B e.Names-E) e.Prefix 0>;

  (e.Names) e.Prefix = ((e.Prefix) e.Names) e.Prefix;
}

DoNewName {
  (e.Names) e.Prefix s.SufNo
    , e.Prefix <Symb s.SufNo>: e.NewName
    , e.Names
    : {
        e.Names-B (e.NewName) e.Names-E
          = <DoNewName
              ((e.NewName) e.Names-B e.Names-E) e.Prefix <+ s.SufNo 1>
            >;

        e.Names = ((e.NewName) e.Names) e.NewName;
      };
}

ScanFunction-Condition-Aux {
  t.Names t.Variables t.SrcPos (e.Name) s.Scope (e.Prefix)
  (e.ScannedFunctions) (e.ScannedSentences)
  (t.Pattern (Condition (e.CondResult) (e.CondPattern)) e.Tail)
  t.Continuation (e.UnscannedFunctions)
    , <OldPatternSteps t.Variables t.Pattern>
    : {
        (() (e.Pattern)) (t.PatternVars /* пусто */) t.NewUsedVars
          /* частный случай — нет открытых переменных */
          , <NewName t.Names e.Name>: t.RefilledNames e.ConditionCheckName
          , <NewName t.NewUsedVars 'e' 'OTHER'>: t.RefilledVars e.eOTHER
          = <ScanFunction
              t.RefilledNames t.SrcPos (e.Name) s.Scope (e.Prefix)
              (e.ScannedFunctions)
              (
                e.ScannedSentences
                (
                  t.Pattern
                  RETURN (
                    (Call
                      () (e.ConditionCheckName)
                      <VariablesAsContext CONTEXT-RESULT t.PatternVars> e.CondResult
                    )
                  )
                )
                <GenContinuation t.Continuation eOTHER-Generator>
              )
              /* нет больше предложений, т.к. переход на континуацию */
              (
                (
                  (e.ConditionCheckName)
                  (
                    (
                      <VariablesAsContext CONTEXT-PATTERN t.PatternVars>
                      e.CondPattern
                    )
                    <PropagateCopiesInTail t.PatternVars e.Tail>
                  )
                  <GenContinuation
                    t.Continuation
                    RestoreFromContext-Generator
                    t.PatternVars (e.Pattern) e.eOTHER
                  >
                )
                e.UnscannedFunctions
              )
            >;

        e.OldPatternSteps t.NewUsedVars
          = <ScanFunction
              t.Names t.SrcPos (e.Name) s.Scope (e.Prefix)
              (e.ScannedFunctions)
              (
                e.ScannedSentences
                (Comment 'Before condition')
                (t.Pattern (Condition (e.CondResult) (e.CondPattern)) e.Tail)
                <DebugPrintPatternSteps e.OldPatternSteps>
                (Comment 'After condition')
                <GenContinuation t.Continuation eOTHER-Generator>
              )
              /* нет больше предложений, т.к. переход на континуацию */
              (e.UnscannedFunctions)
            >;
      };
}

OldPatternSteps {
  t.UsedVars (e.Pattern)
    = (() (e.Pattern))
      <DoOldPatternSteps t.UsedVars (/* pattern vars */) (e.Pattern)>
}

DoOldPatternSteps {
  t.UsedVars t.PatternVars e.SubPatterns-B (t.Symbol e.Expr) e.SubPatterns-E
    , <Symbol t.Symbol>: True
    = <DoOldPatternSteps
        t.UsedVars t.PatternVars e.SubPatterns-B (e.Expr) e.SubPatterns-E
      >;

  t.UsedVars t.PatternVars e.SubPatterns-B (e.Expr t.Symbol) e.SubPatterns-E
    , <Symbol t.Symbol>: True
    = <DoOldPatternSteps
        t.UsedVars t.PatternVars e.SubPatterns-B (e.Expr) e.SubPatterns-E
      >;

  t.UsedVars t.PatternVars e.SubPatterns-B (t.Var e.Expr) e.SubPatterns-E
    , <HardVariable t.PatternVars t.Var>: True s.Type e.Index
    , <AddVariable t.UsedVars t.PatternVars s.Type e.Index>
    : t.NewUsedVars t.NewPatternVars
    = <DoOldPatternSteps
        t.NewUsedVars t.NewPatternVars e.SubPatterns-B (e.Expr) e.SubPatterns-E
      >;

  t.UsedVars t.PatternVars e.SubPatterns-B (e.Expr t.Var) e.SubPatterns-E
    , <HardVariable t.PatternVars t.Var>: True s.Type e.Index
    , <AddVariable t.UsedVars t.PatternVars s.Type e.Index>
    : t.NewUsedVars t.NewPatternVars
    = <DoOldPatternSteps
        t.NewUsedVars t.NewPatternVars e.SubPatterns-B (e.Expr) e.SubPatterns-E
      >;

  t.UsedVars t.PatternVars
  e.SubPatterns-B ((Brackets e.SubExpr) e.Expr) e.SubPatterns-E
    = <DoOldPatternSteps
        t.UsedVars t.PatternVars
        e.SubPatterns-B (e.SubExpr) (e.Expr) e.SubPatterns-E
      >;

  t.UsedVars t.PatternVars
  e.SubPatterns-B (e.Expr (Brackets e.SubExpr)) e.SubPatterns-E
    = <DoOldPatternSteps
        t.UsedVars t.PatternVars
        e.SubPatterns-B (e.Expr) (e.SubExpr) e.SubPatterns-E
      >;

  t.UsedVars t.PatternVars e.SubPatterns-B () e.SubPatterns-E
    = <DoOldPatternSteps
        t.UsedVars t.PatternVars e.SubPatterns-B e.SubPatterns-E
      >;

  t.UsedVars t.PatternVars
  e.SubPatterns-B ((Variable t.SrcPos 'e' e.Index)) e.SubPatterns-E
    , <AddVariable t.UsedVars t.PatternVars 'e' e.Index>
    : t.NewUsedVars e.NewPatternVars
    = <DoOldPatternSteps
        t.NewUsedVars e.NewPatternVars e.SubPatterns-B e.SubPatterns-E
      >;

  t.UsedVars t.PatternVars /* пусто */ =
    (t.PatternVars /* пусто */) t.UsedVars;

  /* Открытая e-переменная */
  t.UsedVars t.PatternVars (t.Variable e.Expr) e.SubPatterns
    , t.Variable: (Variable t.SrcPos 'e' e.Index)
    , <AddVariable t.UsedVars t.PatternVars 'e' e.Index>
    : t.NewUsedVars t.NewPatternVars
    = (t.PatternVars (t.Variable e.Expr) e.SubPatterns)
      <DoOldPatternSteps
        t.NewUsedVars t.NewPatternVars (e.Expr) e.SubPatterns
      >;
}

Symbol {
  (Compound e.Chars) = True;
  (Number s.Number) = True;
  (Char s.Char) = True;
  t.Other = False;
}

HardVariable {
  t.PatternVars (Variable t.SrcPos 's' e.Index) = True 's' e.Index;
  t.PatternVars (Variable t.SrcPos 't' e.Index) = True 't' e.Index;

  (e.PatternVars-B (s.Type (e.Index) e.Repeated) e.PatternVars-E)
  (Variable t.SrcPos s.Type e.Index)
    = True s.Type e.Index;

  t.PatternVars t.Other = False;
}

AddVariable {
  t.UsedVars (e.PatternVars-B (s.Type (e.Index) e.Repeated) e.PatternVars-E)
  s.Type e.Index
    , <NewName t.UsedVars s.Type e.Index>: t.NewUsedVars s.Type e.NewIndex
    = t.NewUsedVars
      (
        e.PatternVars-B
        (s.Type (e.Index) e.Repeated (e.NewIndex))
        e.PatternVars-E
      );

  t.UsedVars (e.PatternVars) s.Type e.Index
    = t.UsedVars (e.PatternVars (s.Type (e.Index)));
}

GenContinuation {
  LAST-SENTENCE s.ContinuationGenerator e.Parameters = /* пусто */;

  (e.FuncName) s.ContinuationGenerator e.Parameters
    = <Mu s.ContinuationGenerator (e.FuncName) e.Parameters>;
}

eOTHER-Generator {
  (e.FuncName)
    = (
        ((Variable () 'eOTHER'))
        RETURN ((Call () (e.FuncName) (Variable () 'eOTHER')))
      );
}

RestoreFromContext-Generator {
  (e.FuncName) t.PatternVars (e.Pattern) e.eOTHER
    = (
        (<VariablesAsContext CONTEXT-PATTERN t.PatternVars> (Variable () e.eOTHER))
        <PropagateCopiesInTail
          t.PatternVars
          RETURN (
            (Call () (e.FuncName) e.Pattern)
          )
        >
      )
}

VariablesAsContext {
  s.Mode (e.Vars) = <DoVariablesAsContext s.Mode e.Vars>;
}

DoVariablesAsContext {
  s.Mode (s.Type (e.Index) (e.NextIndex) e.Indexes) e.Vars
    = <MakeVariableAsContext s.Type <Mu s.Mode (e.Index) e.NextIndex>>
      <DoVariablesAsContext s.Mode (s.Type (e.Index) e.Indexes) e.Vars>;

  s.Mode (s.Type (e.Index)) e.Vars
    = <MakeVariableAsContext s.Type e.Index>
      <DoVariablesAsContext s.Mode e.Vars>;

  s.Mode /* пусто */ = /* пусто */;
}

CONTEXT-PATTERN {
  (e.OrigIndex) e.RepeatedIndex = e.RepeatedIndex;
}

CONTEXT-RESULT {
  (e.OrigIndex) e.RepeatedIndex = e.OrigIndex;
}

MakeVariableAsContext {
  'e' e.Index = (Brackets (Variable () 'e' e.Index));
  s.Type e.Index = (Variable () s.Type e.Index);
}

PropagateCopiesInTail {
  ((s.Type (e.Index)) e.Vars) e.Tail
    = <PropagateCopiesInTail (e.Vars) e.Tail>;

  () e.Tail = e.Tail;

  ((s.Type (e.OrigIndex) (e.CopyIndex) e.Indexes) e.Vars) e.Tail
    = <PropagateCopiesInTail
        ((s.Type (e.OrigIndex) e.Indexes) e.Vars)
        <PropagateInTail s.Type (e.OrigIndex) (e.CopyIndex) e.Tail>
      >;
}

PropagateInTail {
  s.Type (e.OrigIndex) (e.CopyIndex) RETURN (e.Result)
    = RETURN (<PropagateInExpr s.Type (e.OrigIndex) (e.CopyIndex) e.Result>);

  s.Type (e.OrigIndex) (e.CopyIndex)
  (Condition (e.CondResult) (e.CondPattern)) e.Tail
    = (Condition
        (<PropagateInExpr s.Type (e.OrigIndex) (e.CopyIndex) e.CondResult>)
        (<PropagateInExpr s.Type (e.OrigIndex) (e.CopyIndex) e.CondPattern>)
      )
      <PropagateInTail s.Type (e.OrigIndex) (e.CopyIndex) e.Tail>;

  s.Type (e.OrigIndex) (e.CopyIndex)
  CALL-BLOCK (e.Result) e.Sentences =
    CALL-BLOCK
    (<PropagateInExpr s.Type (e.OrigIndex) (e.CopyIndex) e.Result>)
    <PropagateInSentences s.Type (e.OrigIndex) (e.CopyIndex) e.Sentences>;
}

PropagateInSentences {
  s.Type (e.OrigIndex) (e.CopyIndex) ((e.Pattern) e.Tail) e.Sentences
    = (
        (<PropagateInExpr s.Type (e.OrigIndex) (e.CopyIndex) e.Pattern>)
        <PropagateInTail s.Type (e.OrigIndex) (e.CopyIndex) e.Tail>
      )
      <PropagateInSentences s.Type (e.OrigIndex) (e.CopyIndex) e.Sentences>;

  s.Type (e.OrigIndex) (e.CopyIndex) /* пусто */ = /* пусто */;
}

PropagateInExpr {
  s.Type (e.OrigIndex) (e.CopyIndex) e.Expr
    = <DoPropagateInExpr
        s.Type (e.OrigIndex) (e.CopyIndex) '$' (/* scanned */) e.Expr '$'
      >;
}

DoPropagateInExpr {
  s.Type (e.OrigIndex) (e.CopyIndex)
  t.MB-Left (e.Scanned) t.NextTerm e.Expr t.MB-Right
    , t.NextTerm
    : {
        (s.Symbol e.Value)
          , Compound Number Char: e.Types-B s.Symbol e.Types-E
          = <DoPropagateInExpr
              s.Type (e.OrigIndex) (e.CopyIndex)
              t.MB-Left (e.Scanned t.NextTerm) e.Expr t.MB-Right
            >;

        (Variable t.SrcPos s.Type e.OrigIndex)
          = <DoPropagateInExpr-UnFold
              t.MB-Left
              e.Scanned (Variable t.SrcPos s.Type e.CopyIndex) e.Expr
              t.MB-Right
            >;

         (Variable t.SrcPos s.OtherType e.OtherIndex)
           = <DoPropagateInExpr
               s.Type (e.OrigIndex) (e.CopyIndex)
               t.MB-Left (e.Scanned t.NextTerm) e.Expr t.MB-Right
             >;

         (Brackets e.SubExpr)
           = <DoPropagateInExpr
               s.Type (e.OrigIndex) (e.CopyIndex)
               (t.MB-Left (e.Scanned) Brackets)
               (/* scanned */) e.SubExpr
               (e.Expr t.MB-Right)
             >;

         (Call t.SrcPos (e.Function) e.SubExpr)
           = <DoPropagateInExpr
               s.Type (e.OrigIndex) (e.CopyIndex)
               (t.MB-Left (e.Scanned) Call t.SrcPos (e.Function))
               (/* scanned */) e.SubExpr
               (e.Expr t.MB-Right)
             >;
       };

  s.Type (e.OrigIndex) (e.CopyIndex)
  (t.MB-Left (e.Scanned) e.BracketsPrefix)
  (e.ScannedInner) /* пусто */
  (e.Expr t.MB-Right)
    = <DoPropagateInExpr
        s.Type (e.OrigIndex) (e.CopyIndex)
        t.MB-Left (e.Scanned (e.BracketsPrefix e.ScannedInner)) e.Expr t.MB-Right
      >;

  s.Type (e.OrigIndex) (e.CopyIndex) '$' (e.Scanned) /* пусто */ '$'
    = e.Scanned;
}

DoPropagateInExpr-UnFold {
  (t.MB-Left (e.Scanned) e.BracketsPrefix) e.SubExpr (e.Expr t.MB-Right)
    = <DoPropagateInExpr-UnFold
        t.MB-Left e.Scanned (e.BracketsPrefix e.SubExpr) e.Expr t.MB-Right
      >;

  '$' e.Expr '$' = e.Expr
}

ScanFunction-Block {
  t.Names t.SrcPos (e.Name) s.Scope (e.Prefix)
  (e.ScannedFunctions) (e.ScannedSentences)
  t.NextSentence e.Sentences (e.UnscannedFunctions)
    = <ScanFunction
        t.Names t.SrcPos (e.Name) s.Scope (e.Prefix)
        (e.ScannedFunctions) (e.ScannedSentences t.NextSentence)
        e.Sentences (e.UnscannedFunctions)
      >;
}

DebugPrintPatternSteps {
  ((e.PatternVars) e.Pattern) e.Steps
    = (Comment
        <PrintPatternVars e.PatternVars>
        '\n'
        <PrintPattern e.Pattern>
      )
      <DebugPrintPatternSteps e.Steps>;

  /* пусто */ = /* пусто */
}

PrintPatternVars {
  (s.Type e.Indexes) t.NextVar e.Vars
    = <PrintVar s.Type e.Indexes> '; ' <PrintPatternVars t.NextVar e.Vars>;

  (s.Type e.Indexes) = <PrintVar s.Type e.Indexes>;

  /* пусто */ = /* пусто */;
}

PrintVar {
  s.Type (e.Index) (e.NextIndex) e.Indexes
    = s.Type '.' e.Index ', ' <PrintVar s.Type (e.NextIndex) e.Indexes>;

  s.Type (e.Index) = s.Type '.' e.Index;
}

PrintPattern {
  (e.SubPattern) (e.NextSubPattern) e.SubPatterns
    = <PrintExpr e.SubPattern> '| '
      <PrintPattern (e.NextSubPattern) e.SubPatterns>;

  (e.SubPattern) = <PrintExpr e.SubPattern>;

  /* пусто */ = /* пусто */
}

PrintExpr {
  t.Term e.Expr = <Concat (<PrintTerm t.Term>) <PrintExpr e.Expr>>;

  /* пусто */ = /* пусто */;
}

PrintTerm {
  (Compound e.Chars) = '\"' <Text e.Chars> '\"';
  (Number s.Number) = <Symb s.Number>;
  (Char s.Char) = '\'' <Text s.Char> '\'';
  (Variable t.SrcPos s.Type e.Index) = s.Type '.' e.Index;
  (Brackets e.Expr) = '(' <PrintExpr e.Expr> ')';
}

Concat {
  (e.Term '\'') ('\'' e.Expr) = e.Term e.Expr;
  (e.Term) = e.Term;
  (e.Term) e.Expr = e.Term ' ' e.Expr;
}

Text {
  '\n' e.Tail = '\\n' <Text e.Tail>;
  s.Other e.Tail = s.Other <Text e.Tail>;
  /* пусто */ = /* пусто */
}

/*
Intersect {
  (e.B1 s.1 e.E1) (e.B2 s.2 e.E2), <Eq s.1 s.2>: True
    = s.1 <Intersect (e.E1) (e.B2 e.E2)>;

  (e.1) (e.2) = пусто
}


Intersect {
  (e.B1 s.1 e.E1) (e.B2 s.2 e.E2)
    = <Intersect1 ((e.B1) s.1 e.E1) ((e.B2) s.2 e.E2) (<Eq s.1 s.2>)>;

  e.OTHER = <Intersect3 e.OTHER>;
}

Intersect1 {
  ((e.B1) s.1 e.E1) ((e.B2) s.2 e.E2) (True)
    = s.1 <Intersect (e.E1) (e.B2 e.E2)>;

  ((e.B1) s.1 e.E1) ((e.B21) t.B2 e.B22 s.2 e.E2) (e.OTHER)
    = <Intersect1 ((e.B1) s.1 e.E1) ((e.B2 t.B2 e.B22) s.2 e.E2) (<Eq s.1 s.2>)>;

  ((e.B1) s.1 e.E1) ((e.B21) e.B22) (e.OTHER)
    = <Intersect2 ((e.B1) s.1 e.E1) (e.B21 e.B22)>;
}

Intersect2 {
  ((e.B11) t.B1 e.B12 s.1 e.E1) (e.B2 s.2 e.E2)
    = <Intersect1 ((e.B11 t.B1 e.B12) s.1 e.E1) ((e.B2) s.2 e.E2) (<Eq s.1 s.2>)>;

  ((e.B1) s.1 e.E1) (e.B21)
    = <Intersect3 (e.B1 s.1 e.E1) (e.B21)>;
}

Intersect3 {
  (e.1) (e.2) = пусто
}


FindXY {
  (e.XB (e.XX) e.XE) e.YB (e.YY) e.YE
    , <CheckX e.XX (e.YY)>: True
    , <CheckY e.XX (e.YY)>: True
    = Ok;

  (e.X) e.Y = Fail;
}


FindXY {
  (e.XB (e.XX) e.XE) e.YB (e.YY) e.YE
    = <FindXY2 ((e.XB) (e.XX) e.XE) (e.YB) (e.YY) e.YE (<CheckX e.XX (e.YY)>)>;

  e.OTHER = <FindXY1 e.OTHER>
}

FindXY1 {
  (e.X) e.Y = Fail;
}

FindXY2 {
  ((e.XB) (e.XX) e.XE) (e.YB) (e.YY) e.YE (True)
    , <CheckY e.XX (e.YY)>: True
    = Ok;

  ((e.XB) (e.XX) e.XE) (e.YB1) t.YB e.YB2 (e.YY) e.YE (e.OTHER)
    = <FindXY2 ((e.XB) (e.XX) e.XE) (e.YB1 t.YB e.YB2) (e.YY) e.YE (<CheckX e.XX (e.YY)>)>;

  ((e.XB) (e.XX) e.XE) (e.YB1) e.YB2 (e.OTHER)
    = <FindXY3 ((e.XB) (e.XX) e.XE) e.YB1 e.YB2>;
}

FindXY3 {
  ((e.XB1) t.XB e.XB2 (e.XX) e.XE) e.YB (e.YY) e.YE
    = <FindXY2 ((e.XB1 t.XB e.XB2) (e.XX) e.XE) (e.YB) (e.YY) e.YE (<CheckX e.XX (e.YY)>)>;

  ((e.XB1) e.XB2) e.YB1
    = <FindXY1 (e.XB1 e.XB2) e.YB1>;
}

FindXY2 {
  ((e.XB) (e.XX) e.XE) (e.YB) (e.YY) e.YE (True)
    = <FindXY22 ((e.XB) (e.XX) e.XE) (e.YB) (e.YY) e.YE (True) (<CheckY e.XX (e.YY)>)>;

  e.OTHER = <FindXY21 e.OTHER>;
}

FindXY21 {
  ((e.XB) (e.XX) e.XE) (e.YB1) t.YB e.YB2 (e.YY) e.YE (e.OTHER)
    = <FindXY2 ((e.XB) (e.XX) e.XE) (e.YB1 t.YB e.YB2) (e.YY) e.YE (<CheckX e.XX (e.YY)>)>;

  ((e.XB) (e.XX) e.XE) (e.YB1) e.YB2 (e.OTHER)
    = <FindXY3 ((e.XB) (e.XX) e.XE) e.YB1 e.YB2>;
}

FindXY22 {
  ((e.XB) (e.XX) e.XE) (e.YB) (e.YY) e.YE (True) (True)
    = Ok;

  ((e.XB) (e.XX) e.XE) (e.YB) (e.YY) e.YE (True) (e.OTHER)
    = <FindXY21 ((e.XB) (e.XX) e.XE) (e.YB) (e.YY) e.YE (True)>;
}


Delim {
  e.Prefix t.Delim e.Suffix, <Delim t.Delim>: True = (e.Prefix) e.Suffix;

  e.NoDelim = NoDelim
}

Delim {
  e.Prefix t.Delim e.Suffix
    = <Delim2 (e.Prefix) t.Delim e.Suffix (<Delim t.Delim>)>;

  e.OTHER = <Delim1 e.OTHER>;
}

Delim1 { e.NoDelim = NoDelim }

Delim2 {
  (e.Prefix) t.Delim e.Suffix (True) = (e.Prefix) e.Suffix;

  (e.Prefix1) t.Prefix e.Prefix2 t.Delim e.Suffix (e.OTHER)
    = <Delim2 (e.Prefix1 t.Prefix e.Prefix2) t.Delim e.Suffix (<Delim t.Delim>)>;

  (e.Prefix) t.Delim e.Suffix (e.OTHER)
    = <Delim1 e.Prefix t.Delim e.Suffix>;
}


Delim {
  e.Prefix e.Prefix t.Delim e.Suffix, <Delim t.Delim>: True = <F e.Prefix> <G e.Prefix>;
  e.Other = Fail;
}


Delim {
  e.Prefix e.Prefix t.Delim e.Suffix
    <Delim2 (e.Prefix) (e.Prefix) t.Delim e.Suffix (<Delim t.Delim>)>

  e.OTHER = <Delim1 e.OTHER>
}

Delim1 { e.Other = Fail }

Delim2 {
  (e.Prefix) (e.Prefix1) t.Delim e.Suffix (True)
    = <F e.Prefix> <G e.Prefix1>;

  (e.Prefix) (e.Prefix1) t.Delim e.Suffix (e.OTHER)
    = <Delim3 (e.Prefix) e.Prefix1 t.Delim e.Suffix>;
}

Delim3 {
  (e.Prefix1) t.Prefix e.Prefix2 e.Prefix1 t.Prefix e.Prefix2 t.Delim e.Suffix
    = <Delim2
        (e.Prefix1 t.Prefix e.Prefix2) (e.Prefix1 t.Prefix e.Prefix2) t.Delim e.Suffix
        (<Delim t.Delim>)
      >;

  (e.Prefix) e.Prefix1 = <Delim1 e.Prefix e.Prefix1>;
}


NonsenceFunc {
  e.Begin (e.Inner) e.Inner e.Begin e.End
    , <Valid e.Begin>: e.End
    = <F e.Begin> <G e.Inner e.End> <H e.Inner e.Begin e.End>;

  s.ABC = s.ABC
}

NonsenceFunc {
  e.Begin (e.Inner) e.Inner e.Begin e.End
    = <NonsenceFunc2 (e.Begin) (e.Inner) (e.Inner) (e.Begin) e.End (<Valid e.Begin>)>;

  e.OTHER = <NonsenceFunc1 e.OTHER>;
}

NonsenceFunc1 { s.ABC = s.ABC }

NonsenceFunc2 {
  (e.Begin) (e.Inner) (e.Inner1) (e.Begin1) e.End (e.End)
    = <F e.Begin> <G e.Inner e.End> <H e.Inner1 e.Begin1 e.End>;

  (e.Begin) (e.Inner) (e.Inner1) (e.Begin1) e.End (e.OTHER)
    = <NonsenceFunc3 (e.Begin) (e.Inner) e.Inner1 e.Begin1 e.End>;
}

NonsenceFunc3 {
  (e.Begin1) t.Begin e.Begin2 (e.Inner) e.Inner e.Begin1 t.Begin e.Begin2 e.End
    = <NonsenceFunc2
        (e.Begin1 t.Begin e.Begin2) (e.Inner) (e.Inner) (e.Begin1 t.Begin e.Begin2) e.End
        (<Valid e.Begin1 t.Begin e.Begin2>)
      >;

  (e.Begin) e.Begin1 = <NonsenceFunc1 e.Begin e.Begin1>;
}



RepeatedNonsence {
  (e.Repeated) e.Repeated e.Tail, <Tail e.Tail>: e.Tail
    = <F (e.Tail) e.Repeated> <F (e.Repeated) e.Tail>;

  s.ABC = s.ABC
}

RepeatedNonsence {
  (e.Repeated) e.Repeated e.Tail
    = <RepeatedNonsence2 (e.Repeated) (e.Repeated) e.Tail (<Tail e.Tail>)>;

  e.OTHER = <RepeatedNonsence1 e.OTHER>;
}

RepeatedNonsence1 { s.ABC = s.ABC }

RepeatedNonsence2 {
  (e.Repeated) (e.Repeated1) e.Tail (e.Tail)
    = <F (e.Tail) e.Repeated> <F (e.Repeated1) e.Tail>;

  (e.Repeated) (e.Repeated1) e.Tail (e.OTHER)
    = <RepeatedNonsence1 (e.Repeated) e.Repeated1 e.Tail>;
}


KeyValue {
  (e.Sample) e.Items-B (e.Key (e.Value)) e.Items-E
    , <EqualNoCase (e.Sample) e.Key>: True = Found e.Value;

  (e.Sample) e.Items = NotFound;
}


KeyValue {
  (e.Sample) e.Items-B (e.Key (e.Value)) e.Items-E
    = <KeyValue2
        (e.Sample) (e.Items-B) (e.Key (e.Value)) e.Items-E
        (<EqualNoCase (e.Sample) e.Key>)
      >;

  e.OTHER = <KeyValue1 e.OTHER>;
}

KeyValue1 {
  (e.Sample) e.Items = NotFound;
}

KeyValue2 {
  (e.Sample) (e.Items-B) (e.Key (e.Value)) e.Items-E (True)
    = Found e.Value;

  (e.Sample) (e.Items-B1) t.Items-B e.Items-B2 (e.Key (e.Value)) e.Items-E
  (e.OTHER)
    = <KeyValue2
        (e.Sample) (e.Items-B1 t.Items-B e.Items-B2) (e.Key (e.Value)) e.Items-E
        (<EqualNoCase (e.Sample) e.Key>)
      >;


  (e.Sample) (e.Items-B1) e.Items-B2
    = <KeyValue1 (e.Sample) e.Items-B1 e.Items-B2>;
}
*/
