//FROM LibraryEx
$EXTERN MapReduce, Map, Reduce, DelAccumulator;

//FROM Error
$EXTERN ErrorAt, Warning, WarningAt;


/*==============================================================================
   Разбор начинается с правила Root, множество :Any: задаёт множество всех
   символов, системная ошибка #TokenUnexpected, пользовательская ошибка
   #TokenError, неожиданный конец — #TokenUnexpectedEOF, в случае ошибки выб-
   расывается также #TokenAccum с содержимым аккумулятора на момент ошибки.
==============================================================================*/

//==============================================================================
// Генератор автомата
//==============================================================================

$ENTRY GenerateFromDFA {
  e.Elements =
    <GenerateAutomat
      <ResolvingSets
        <Separate e.Elements>
      >
    >;
}

SeparateOne {
  ( (e.Sets) (e.Rules) ) (#Set (e.Name) e.Content) =
    ( (e.Sets ((e.Name) e.Content)) (e.Rules) );

  ( (e.Sets) (e.Rules) ) (#Sentence (e.Name) e.Content) =
    ( (e.Sets) (e.Rules ((e.Name) e.Content)) );
}

Separate {
  e.Elements =
    <Reduce SeparateOne ((/* sets */) (/* rules */)) e.Elements>;
}

ResolvingSets {
  ( (e.Sets) (e.Rules) ) =
    (<ResolvingSets-Aux e.Sets>)
    (e.Rules);
}

NormingSet {
  e.Set-B s.Repeated e.Set-M s.Repeated e.Set-E =
    e.Set-B <NormingSet s.Repeated e.Set-M e.Set-E>;

  e.Set = e.Set;
}

ResolvingSets-Aux {
  e.Sets =
    <SetSubstitute
      <SetCheckRecursion
        <SetPartNormalize
          e.Sets
        >
      >
    >;
}

NormalizeContent {
  (e.Chars) (#Chars e.Symbols) e.Tail =
    <NormalizeContent
      (<NormingSet e.Chars e.Symbols>) e.Tail
    >;

  (e.Chars) (#Set s.LineNumber e.Name) e.Tail =
    (#Set s.LineNumber e.Name) <NormalizeContent (e.Chars) e.Tail>;

  (e.Chars) = (#Chars e.Chars);
}

SetPartNormalizeOne {
  ((e.Name) #Any) = ((e.Name) #Any);

  ((e.Name) e.Content) = ((e.Name) <NormalizeContent () e.Content>);
}

SetPartNormalize {
  e.Sets = <Map SetPartNormalizeOne e.Sets>;
}

SetCheckRecursion {
  e.Sets-B
  ((e.Name) e.Content-B (#Set s.LineNumber e.Name) e.Content-E)
  e.Sets-E =
    // Рекурсивная зависимость множеств — не ошибка.
    <WarningAt s.LineNumber 'Recursive depended set ' e.Name>
    <SetCheckRecursion
      e.Sets-B ((e.Name) e.Content-B e.Content-E) e.Sets-E
    >;

  e.Sets = e.Sets;
}

SetSubstitute {
  e.Sets-B
  ( (e.Name) e.Content-B (#Set t.SrcPos 'Any') e.Content-E )
  e.Sets-E =
    <ResolvingSets-Aux
      e.Sets-B ( (e.Name) #Any ) e.Sets-E
    >;

  e.Sets-B
  ( (e.Name) e.Content-B (#Set t.SrcPos e.IncName) e.Content-E )
  e.Sets-M
  ( (e.IncName) e.IncContent )
  e.Sets-E =
    <ResolvingSets-Aux
      e.Sets-B ( (e.Name) e.Content-B e.IncContent e.Content-E )
      e.Sets-M ( (e.IncName) e.IncContent ) e.Sets-E
    >;

  e.Sets-B
  ( (e.IncName) e.IncContent )
  e.Sets-M
  ( (e.Name) e.Content-B (#Set t.SrcPos e.IncName) e.Content-E )
  e.Sets-E =
    <ResolvingSets-Aux
      e.Sets-B ( (e.IncName) e.IncContent ) e.Sets-M
      ( (e.Name) e.Content-B e.IncContent e.Content-E ) e.Sets-E
    >;

  e.Sets-B
  ( (e.Name) e.Content-B (#Set s.LineNumber e.IncName) e.Content-E )
  e.Sets-E =
    <ErrorAt s.LineNumber 'set ' e.IncName ' not defined'>;

  e.Sets = e.Sets;
}

SimplifySet {
  ((e.Name) #Any) = ((e.Name) #NotUsed #Any);

  ((e.Name) (#Chars e.Content)) =
    ((e.Name) #NotUsed #Chars e.Content);
}

GenerateAutomat {
  (e.Sets) (e.Rules) =
    <SubstituteSetsToRules
      (<Map SimplifySet e.Sets>)
      (e.Rules)
    >;
}

SubstituteSetsToRules {
  ( ((e.Name) s.Used #Chars e.Content) e.Sets )
  (
    e.Rules-B
    ((e.RuleName)
      e.Alternatives-B
      ( (#Set t.SrcPos e.Name) t.Flush t.NextState )
      e.Alternatives-E
    )
    e.Rules-E
  ) =
    <SubstituteSetsToRules
      ( ((e.Name) #Used #Chars e.Content) e.Sets )
      (
        e.Rules-B
        ((e.RuleName)
          e.Alternatives-B
          ( (#Chars e.Content) t.Flush t.NextState )
          e.Alternatives-E
        )
        e.Rules-E
      )
    >;

  ( ((e.Name) s.Used #Any) e.Sets )
  (
    e.Rules-B
    ((e.RuleName)
      e.Alternatives-B
      ( (#Set t.SrcPos e.Name) t.Flush t.NextState )
      e.Alternatives-E
    )
    e.Rules-E
  ) =
    <SubstituteSetsToRules
      ( ((e.Name) s.Used #Any) e.Sets )
      (
        e.Rules-B
        ((e.RuleName)
          e.Alternatives-B
          ( #Any t.Flush t.NextState )
          e.Alternatives-E
        )
        e.Rules-E
      )
    >;

  ( ((e.Name) #NotUsed e.Content) e.Sets ) (e.Rules) =
    // Строчка закомментирована, т.к. часты ложноположительные
    // срабатывания, а значит предупреждение смысла не несёт.
    // <Warning 'Set ' e.Name ' not used'>
    <SubstituteSetsToRules (e.Sets) (e.Rules)>;

  // Для первого в списке множества не найдено вхождения
  ( ((e.Name) #Used e.Content) e.Sets ) (e.Rules) =
    <SubstituteSetsToRules (e.Sets) (e.Rules)>;

  ()
  (
    e.Rules-B
    ((e.RuleName)
      e.Alternatives-B
      ( (#Set t.SrcPos 'Any') t.Flush t.NextState )
      e.Alternatives-E
    )
    e.Rules-E
  ) =
    <SubstituteSetsToRules
      ()
      (
        e.Rules-B
        ((e.RuleName)
          e.Alternatives-B
          ( #Any t.Flush t.NextState )
          e.Alternatives-E
        )
        e.Rules-E
      )
    >;

  ()
  (
    e.Rules-B
    ((e.RuleName)
      e.Alternatives-B
      ( (#Set s.LineNumber e.Name) t.Flush t.NextState )
      e.Alternatives-E
    )
    e.Rules-E
  ) =
    <ErrorAt s.LineNumber 'Undeclared set ' e.Name>;

  () (e.Rules) = <GenerateSentences e.Rules>;
}

GenerateSentences {
  e.Rules =
    <WriteCode
      <Map NormalizeRule e.Rules>
    >;
}

SetDiff {
  (e.Set) (#Any) = ;

  (e.Set1-B s.Common e.Set1-E) (e.Set2-B s.Common e.Set2-E) =
    <SetDiff (e.Set1-B e.Set1-E) (e.Set2-B e.Set2-E)>;

  (e.SetDiff) (e.Set2) = e.SetDiff;
}

NormalizeAlternative {
  (e.Diff) ((#Chars e.Alternative) t.Flush t.Next) =
    (<NormingSet e.Diff e.Alternative>)
    ((<SetDiff (e.Alternative) (e.Diff)>) t.Flush t.Next);

  (e.Diff) (#Any t.Flush t.Next) =
    (#Any)
    (#Any t.Flush t.Next);

  (e.Diff) ( #Empty t.Flush t.Next ) =
    (e.Diff) ( #Empty t.Flush t.Next );
}

SplitAlternatives {
  ( #Empty t.Flush t.Next ) = (#Empty t.Flush t.Next);

  ( #Any t.Flush t.Next ) = (#Any t.Flush t.Next);

  ( (s.Char) t.Flush t.Next ) = (s.Char t.Flush t.Next);

  ( (s.Char e.Tail) t.Flush t.Next ) =
    (s.Char t.Flush t.Next)
    <SplitAlternatives ( (e.Tail) t.Flush t.Next )>;
}

NormalizeRule {
  ((e.Name) e.Alternatives) =
    ((e.Name)
      <Map
        SplitAlternatives
        <DelAccumulator
          <MapReduce
            NormalizeAlternative
            () e.Alternatives
          >
        >
      >
    );
}

WriteCode {
  e.Rules =
    <WriteFunctions
      (/* written */) (/* expected */ (0 'Root'))
      e.Rules
    >;
}

ExtractExpected {
  ( t.Head t.Flush #Finitive ) = ;

  ( t.Head t.Flush ( s.LineNumber e.NextName ) ) =
    ( s.LineNumber e.NextName );
}

WriteFunctions {
  (e.Written) () = ;

  (e.Written) () ((e.Name) e.Content) e.Rules =
    <Warning 'Found unused rules ' e.Name ' ...'>;

  (e.Written-B (e.Next) e.Written-E)
  ((s.LineNumber e.Next) e.Expected) e.Rules =
    <WriteFunctions
      (e.Written-B (e.Next) e.Written-E)
      ( e.Expected ) e.Rules
    >;

  (e.Written) ((s.LineNumber e.NextRule) e.Expected)
  e.Rules-B ((e.NextRule) e.Alternatives) e.Rules-E =
    <WriteFunction
      (e.NextRule)
      e.Alternatives
    >
    <WriteFunctions
      (e.Written (e.NextRule))
      ( e.Expected <Map ExtractExpected e.Alternatives> )
      e.Rules-B e.Rules-E
    >;

  ((s.LineNumber e.NextRule) e.Expected) e.Rules =
    <ErrorAt s.LineNumber 'Rule ' e.NextRule ' not found'>;
}

WriteFunction {
  (e.NextRule) e.Alternatives =
    ()
    (e.NextRule ' {')
    <Map WriteAlternative e.Alternatives>
    ('  (e.Accum) s.Unexpected e.Text =')
    ('    (#TokenUnexpected s.Unexpected) <Root () e.Text>;')
    ('  (e.Accum) = (#TokenAccum e.Accum) (#TokenUnexpectedEOF);')
    ('}');
}

/*
t.Head ::= #Empty | s.Char

t.Flush ::= #None | #Unnamed | (#Flush e.FlushName) | (#FlushError e.Message)

t.NextState ::= (t.SrcPos e.NextStateName) | #Finitive
*/

WriteAlternative {
  (#Empty #None #Finitive) =
    ('  (e.Accum) = (#TokenAccum e.Accum) ;');

  (#Empty #None (t.SrcPos e.NextStateName)) =
    ('  (e.Accum) e.Text = <' e.NextStateName ' (e.Accum) e.Text>;');

  (#Empty #Unnamed #Finitive) =
    ('  (e.Accum) = ;');

  (#Empty #Unnamed (t.SrcPos e.NextStateName)) =
    ('  (e.Accum) e.Text = <' e.NextStateName ' () e.Text>;');

  (#Empty (#Flush e.FlushName) #Finitive) =
    ('  (e.Accum) =  (' e.FlushName ' e.Accum);');

  (#Empty (#Flush e.FlushName) (t.SrcPos e.NextStateName)) =
    ('  (e.Accum) e.Text =')
    ('    (' e.FlushName ' e.Accum) <' e.NextStateName ' () e.Text>;');

  (#Empty (#FlushError e.Message) #Finitive) =
    ('  (e.Accum) = (#TokenError ' '' e.Message '' ');');

  (#Empty (#FlushError e.Message) (t.SrcPos e.NextStateName)) =
    (
      '  (e.Accum) e.Text = '
      '(#TokenError ' '' e.Message '' ') <' e.NextStateName ' () e.Text>;'
    );

  (s.Char #None #Finitive) =
    ('  (e.Accum) ' <EC s.Char> ' = (#TokenAccum e.Accum ' <EC s.Char> ');');

  (s.Char #None (t.SrcPos e.NextStateName)) =
    (
      '  (e.Accum) ' <EC s.Char> ' e.Text = '
      '<' e.NextStateName ' (e.Accum ' <EC s.Char> ') e.Text>;'
    );

  (s.Char #Unnamed #Finitive) =
    ('  (e.Accum) ' <EC s.Char> ' = ;');

  (s.Char #Unnamed (t.SrcPos e.NextStateName)) =
    ('  (e.Accum) ' <EC s.Char> ' e.Text = <' e.NextStateName ' () e.Text>;');

  (s.Char (#Flush e.FlushName) #Finitive) =
    (
      '  (e.Accum) ' <EC s.Char> ' = '
      '(' e.FlushName ' e.Accum ' <EC s.Char> ');'
    );

  (s.Char (#Flush e.FlushName) (t.SrcPos e.NextStateName)) =
    (
      '  (e.Accum) ' <EC s.Char> ' e.Text = '
      '(' e.FlushName ' e.Accum ' <EC s.Char> ') '
      '<' e.NextStateName ' () e.Text>;'
    );

  (s.Char (#FlushError e.Message) #Finitive) =
    ('  (e.Accum) ' <EC s.Char> ' = (#TokenError ' '' e.Message '' ');');

  (s.Char (#FlushError e.Message) (t.SrcPos e.NextStateName)) =
    (
      '  (e.Accum) ' <EC s.Char> ' e.Text = '
      '(#TokenError ' '' e.Message '' ') <' e.NextStateName ' () e.Text >;'
    );
}

//FROM Escape
$EXTERN EscapeChar;

//EscapeChar
EC {
  #Any = 's.Any';
  s.Other = '' <EscapeChar s.Other> '';
}
