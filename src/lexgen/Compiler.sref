//FROM LibraryEx
$EXTERN Fetch, Seq, MapReduce, Map, Reduce, DelAccumulator;

//FROM Error
$EXTERN ErrorAt, Warning, WarningAt;


/*==============================================================================
   Разбор начинается с правила Root, множество :Any: задаёт множество всех
   символов, системная ошибка #TokenUnexpected, пользовательская ошибка
   #TokenError, неожиданный конец — #TokenUnexpectedEOF, в случае ошибки выб-
   расывается также #TokenAccum с содержимым аккумулятора на момент ошибки.
==============================================================================*/

//==============================================================================
// Генератор автомата
//==============================================================================

$ENTRY PrepareDFA {
  e.Elements =
    <Fetch
      e.Elements
      <Seq
        (Reduce
          {
            ((e.Sets) (e.Rules))
            (#Set (e.Name) e.Content) =
              (
                (e.Sets ((e.Name) e.Content))
                (e.Rules)
              );

            ((e.Sets) (e.Rules))
            (#Sentence (e.Name) e.Content) =
              (
                (e.Sets)
                (e.Rules ((e.Name) e.Content))
              );
          }
          ((/* sets */) (/* rules */))
        )
        {
          ((e.Sets) (e.Rules)) =
            (<Map SimplifySet <ResolvingSets e.Sets>>)
            (e.Rules);
        }
        SubstituteSetsToRules
        /* e.Rules */
        (Map NormalizeRule)
        PrepareFunctions
      >
    >;
}

UniqueSet {
  e.Set-B s.Repeated e.Set-M s.Repeated e.Set-E =
    e.Set-B <UniqueSet s.Repeated e.Set-M e.Set-E>;

  e.Set = e.Set;
}

ResolvingSets {
  e.Sets =
    <Fetch
      e.Sets
      <Seq
        (Map
          {
            ((e.Name) #Any) = ((e.Name) #Any);

            ((e.Name) e.Content) = ((e.Name) <NormalizeContent () e.Content>);
          }
        )
        SetCheckRecursion
        SetSubstitute
        {
          #Changed e.Sets^ = <ResolvingSets e.Sets>;

          #NotChanged e.Sets^ = e.Sets;
        }
      >
    >;
}

NormalizeContent {
  (e.Chars) (#Chars e.Symbols) e.Tail =
    <NormalizeContent
      (<UniqueSet e.Chars e.Symbols>) e.Tail
    >;

  (e.Chars) (#Set t.SrcPos e.Name) e.Tail =
    (#Set t.SrcPos e.Name) <NormalizeContent (e.Chars) e.Tail>;

  (e.Chars) = (#Chars e.Chars);
}

SetCheckRecursion {
  e.Sets-B
  ((e.Name) e.Content-B (#Set t.SrcPos e.Name) e.Content-E)
  e.Sets-E =
    // Рекурсивная зависимость множеств — не ошибка.
    <WarningAt t.SrcPos 'Recursive depended set ' e.Name>
    <SetCheckRecursion
      e.Sets-B ((e.Name) e.Content-B e.Content-E) e.Sets-E
    >;

  e.Sets = e.Sets;
}

SetSubstitute {
  e.Sets-B
  ( (e.Name) e.Content-B (#Set t.SrcPos 'Any') e.Content-E )
  e.Sets-E =
    #Changed e.Sets-B ( (e.Name) #Any ) e.Sets-E;

  e.Sets-B
  ( (e.Name) e.Content-B (#Set t.SrcPos e.IncName) e.Content-E )
  e.Sets-M
  ( (e.IncName) e.IncContent )
  e.Sets-E =
    #Changed
    e.Sets-B ( (e.Name) e.Content-B e.IncContent e.Content-E )
    e.Sets-M ( (e.IncName) e.IncContent ) e.Sets-E;

  e.Sets-B
  ( (e.IncName) e.IncContent )
  e.Sets-M
  ( (e.Name) e.Content-B (#Set t.SrcPos e.IncName) e.Content-E )
  e.Sets-E =
    #Changed
    e.Sets-B ( (e.IncName) e.IncContent ) e.Sets-M
    ( (e.Name) e.Content-B e.IncContent e.Content-E ) e.Sets-E;

  e.Sets-B
  ( (e.Name) e.Content-B (#Set t.SrcPos e.IncName) e.Content-E )
  e.Sets-E =
    <ErrorAt t.SrcPos 'set ' e.IncName ' not defined'>;

  e.Sets = #NotChanged e.Sets;
}

SimplifySet {
  ((e.Name) #Any) = ((e.Name) #NotUsed #Any);

  ((e.Name) (#Chars e.Content)) =
    ((e.Name) #NotUsed #Chars e.Content);
}

SubstituteSetsToRules {
  ( ((e.Name) s.Used #Chars e.Content) e.Sets )
  (
    e.Rules-B
    ((e.RuleName)
      e.Alternatives-B
      ( (#Set t.SrcPos e.Name) t.Flush t.NextState )
      e.Alternatives-E
    )
    e.Rules-E
  ) =
    <SubstituteSetsToRules
      ( ((e.Name) #Used #Chars e.Content) e.Sets )
      (
        e.Rules-B
        ((e.RuleName)
          e.Alternatives-B
          ( (#Chars e.Content) t.Flush t.NextState )
          e.Alternatives-E
        )
        e.Rules-E
      )
    >;

  ( ((e.Name) s.Used #Any) e.Sets )
  (
    e.Rules-B
    ((e.RuleName)
      e.Alternatives-B
      ( (#Set t.SrcPos e.Name) t.Flush t.NextState )
      e.Alternatives-E
    )
    e.Rules-E
  ) =
    <SubstituteSetsToRules
      ( ((e.Name) s.Used #Any) e.Sets )
      (
        e.Rules-B
        ((e.RuleName)
          e.Alternatives-B
          ( #Any t.Flush t.NextState )
          e.Alternatives-E
        )
        e.Rules-E
      )
    >;

  ( ((e.Name) #NotUsed e.Content) e.Sets ) (e.Rules) =
    // Строчка закомментирована, т.к. часты ложноположительные
    // срабатывания, а значит предупреждение смысла не несёт.
    // <Warning 'Set ' e.Name ' not used'>
    <SubstituteSetsToRules (e.Sets) (e.Rules)>;

  // Для первого в списке множества не найдено вхождения
  ( ((e.Name) #Used e.Content) e.Sets ) (e.Rules) =
    <SubstituteSetsToRules (e.Sets) (e.Rules)>;

  ()
  (
    e.Rules-B
    ((e.RuleName)
      e.Alternatives-B
      ( (#Set t.SrcPos 'Any') t.Flush t.NextState )
      e.Alternatives-E
    )
    e.Rules-E
  ) =
    <SubstituteSetsToRules
      ()
      (
        e.Rules-B
        ((e.RuleName)
          e.Alternatives-B
          ( #Any t.Flush t.NextState )
          e.Alternatives-E
        )
        e.Rules-E
      )
    >;

  ()
  (
    e.Rules-B
    ((e.RuleName)
      e.Alternatives-B
      ( (#Set t.SrcPos e.Name) t.Flush t.NextState )
      e.Alternatives-E
    )
    e.Rules-E
  ) =
    <ErrorAt t.SrcPos 'Undeclared set ' e.Name>;

  () (e.Rules) = e.Rules;
}

SetDiff {
  (e.Set) (#Any) = ;

  (e.Set1-B s.Common e.Set1-E) (e.Set2-B s.Common e.Set2-E) =
    <SetDiff (e.Set1-B e.Set1-E) (e.Set2-B e.Set2-E)>;

  (e.SetDiff) (e.Set2) = e.SetDiff;
}

NormalizeAlternative {
  (e.Diff) ((#Chars e.Alternative) t.Flush t.Next) =
    (<UniqueSet e.Diff e.Alternative>)
    ((<SetDiff (e.Alternative) (e.Diff)>) t.Flush t.Next);

  (e.Diff) (#Any t.Flush t.Next) =
    (#Any)
    (#Any t.Flush t.Next);

  (e.Diff) ( #Empty t.Flush t.Next ) =
    (e.Diff) ( #Empty t.Flush t.Next );
}

SplitAlternatives {
  ( #Empty t.Flush t.Next ) = (#Empty t.Flush t.Next);

  ( #Any t.Flush t.Next ) = (#Any t.Flush t.Next);

  ( (s.Char) t.Flush t.Next ) = (s.Char t.Flush t.Next);

  ( (s.Char e.Tail) t.Flush t.Next ) =
    (s.Char t.Flush t.Next)
    <SplitAlternatives ( (e.Tail) t.Flush t.Next )>;
}

NormalizeRule {
  ((e.Name) e.Alternatives) =
    <Fetch
      e.Alternatives
      <Seq
        (MapReduce
          NormalizeAlternative
          ()
        )
        DelAccumulator
        (Map SplitAlternatives)
        {
          e.Alternatives^ =
            ((e.Name) e.Alternatives);
        }
      >
    >;
}

PrepareFunctions {
  e.Rules =
    <DoPrepareFunctions
      (/* written */) (/* expected */ ((0 'runtime') 'Root'))
      e.Rules
    >;
}

ExtractExpected {
  ( t.Head t.Flush #Finitive ) = ;

  ( t.Head t.Flush ( t.SrcPos e.NextName ) ) =
    ( t.SrcPos e.NextName );
}

DoPrepareFunctions {
  (e.Written) () = ;

  (e.Written) () ((e.Name) e.Content) e.Rules =
    <Warning 'Found unused rules ' e.Name ' ...'>;

  (e.Written-B (e.Next) e.Written-E)
  ((t.SrcPos e.Next) e.Expected) e.Rules =
    <DoPrepareFunctions
      (e.Written-B (e.Next) e.Written-E)
      ( e.Expected ) e.Rules
    >;

  (e.Written) ((t.SrcPos e.NextRule) e.Expected)
  e.Rules-B ((e.NextRule) e.Alternatives) e.Rules-E =
    ((e.NextRule) e.Alternatives)
    <DoPrepareFunctions
      (e.Written (e.NextRule))
      ( e.Expected <Map ExtractExpected e.Alternatives> )
      e.Rules-B e.Rules-E
    >;

  (e.Written) ((t.SrcPos e.NextRule) e.Expected) e.Rules =
    <ErrorAt t.SrcPos 'Rule ' e.NextRule ' not found'>;
}
