//FROM LibraryEx
$EXTERN Map, Fetch, Seq, MapReduce, Inc, Dec, Compare;

//FROM Library
$EXTERN Add, StrFromInt;

//FROM Escape
$EXTERN EscapeChar;

/**
  <HightLevelRASL e.AST>
    == e.RASLAST

  e.RASLAST ::= t.RASLFunction*
  t.RASLFunction ::=
      (#Function s.ScopeClass (e.Name) t.HiRASLCommand*)
    | (s.SingularItem s.ScopeClass e.Name)
    | (#Ident e.Name)
    | (#Separator)
  s.SingularItem ::= #Enum | #Swap | #Stub | #Declaration
  t.HiRASLCommand ::=
      (#Cmd… e.Value)
    | (#CmdSentence t.HiRASLCommand*)
    | (#CmdOpenELoop #AlgLeft s.BracketNum s.VarNumber t.HiRASLCommand*)
*/
$ENTRY HightLevelRASL {
  e.ProgramElements =
    <Map
      {
        (#Function s.ScopeClass (e.Name) e.Sentences) =
          <HightLevelRASL-Function
            s.ScopeClass (e.Name) e.Sentences
          >;

        (#Enum s.ScopeClass e.Name) =
          (#CmdEnum s.ScopeClass e.Name);

        (#Swap s.ScopeClass e.Name) =
          (#CmdSwap s.ScopeClass e.Name);

        (#Stub s.ScopeClass e.Name) =
          /* пусто */;

        (#Declaration s.ScopeClass e.Name) =
          (#CmdDeclaration s.ScopeClass e.Name);

        (#Ident e.Name) = (#CmdDefineIdent e.Name);

        (#Separator) = (#CmdSeparator);
      }
      e.ProgramElements
    >;
}

HightLevelRASL-Function {
  s.ScopeClass (e.Name) e.Sentences =
    <Fetch
      e.Sentences
      <Seq
        (Map
          {
            ((e.Pattern) (e.Result)) =
              (<HightLevelRASL-Sentence (e.Pattern) (e.Result)>);
          }
        )
        (MapReduce
          {
            s.MaxMemory ((#CmdIssueMem s.Memory) e.Sentence) =
              <Fetch
                <Compare s.MaxMemory s.Memory> {
                  '<' = s.Memory;
                  s.Other = s.MaxMemory;
                }
              >
              (#CmdSentence e.Sentence);
          }
          0
        )
        {
          s.MaxMemory e.Sentences^ (#CmdSentence e.LastSentence) =
            (#Function
              s.ScopeClass (e.Name)
              (#CmdIssueMem s.MaxMemory)
              e.Sentences
              <Fetch
                e.LastSentence
                {
                  e.Commands (#CmdOpenELoop e.OpenELoop) =
                    e.Commands (#CmdOpenELoop e.OpenELoop) (#CmdFail);

                  e.LastSentence^ = e.LastSentence;
                }
              >
            );
        }
      >
    >;
}

HightLevelRASL-Sentence {
  (e.Pattern) (e.Result) =
    <Fetch
      <GenPattern e.Pattern>
      {
        (e.PatternVars) s.ContextOffset (e.PatternCommands) =
          <GeneralizeResult
            (e.PatternVars) (e.PatternCommands)
            <GenResult s.ContextOffset e.Result>
          >;
      }
    >;
}

GeneralizeResult {
  (e.PatternVars) (e.PatternCommands)
  s.ContextCount (e.ResultVars) (e.ResultCommands) =
    <Fetch
      (<ReplicateVars e.PatternVars>)
      <ReplicateVars e.ResultVars>
      <Seq
        {
          (e.PatternVars^) e.ResultVars^ =
            (<VarSetUnion (e.PatternVars) (e.ResultVars)>)
            <VarSetDifference (e.ResultVars) (e.PatternVars)>;
        }
        {
          (e.CommonVars) e.CopiedVars =
            (
              <MapReduce
                {
                  s.Number (s.Usings 'e' e.Index) =
                    <Add s.Number 2> (s.Number s.Usings 'e' e.Index);

                  s.Number (s.Usings s.Mode e.Index) =
                    <Inc s.Number> (s.Number s.Usings s.Mode e.Index);
                }
                s.ContextCount e.CommonVars
              >
            )
            e.CopiedVars;
        }
        {
          (s.Number e.CommonVars) e.CopiedVars =
            <FoldOpenELoops
              (#CmdIssueMem s.Number)
              (#CmdInitB0)
              <PatchVariableNumbers
                (e.CommonVars)
                e.PatternCommands
                (#CmdEmptyResult)
                <Map (MakeCopyVar e.CommonVars) e.CopiedVars>
                <Map (SetOffsetForCmdInsertVar e.CommonVars) e.ResultCommands>
              >
              (#CmdReturnResult)
            >;
        }
      >
    >;
}

FoldOpenELoops {
  e.Commands-B (#CmdOpenedE #AlgLeft s.BracketNum s.VarNumber) e.Commands-E =
    e.Commands-B
    (#CmdOpenELoop
      #AlgLeft s.BracketNum s.VarNumber
      <FoldOpenELoops e.Commands-E>
    );

  e.Commands = e.Commands;
}

ReplicateVar {
  (1 s.Mode e.Index) = (1 s.Mode e.Index);

  (s.Using s.Mode e.Index) =
    <ReplicateVar (<Dec s.Using> s.Mode e.Index)>
    (s.Using s.Mode e.Index);
}

ReplicateVars {
  e.Vars = <Map ReplicateVar e.Vars>;
}

VarSetUnion {
  (t.Common e.Set1) (e.Set2-B t.Common e.Set2-E) =
    t.Common <VarSetUnion (e.Set1) (e.Set2-B e.Set2-E)>;

  (t.OnlyInSet1 e.Set1) (e.Set2) =
    t.OnlyInSet1 <VarSetUnion (e.Set1) (e.Set2)>;

  () (e.Set2) = e.Set2;
}

VarSetDifference {
  (t.Common e.Set1) (e.Set2-B t.Common e.Set2-E) =
    <VarSetDifference (e.Set1) (e.Set2-B e.Set2-E)>;

  (t.OnlyInSet1 e.Set1) (e.Set2) =
    t.OnlyInSet1 <VarSetDifference (e.Set1) (e.Set2)>;

  () (e.Set2) = /* пусто */;
}

SetOffsetForCmdInsertVar {
  e.Vars-B (s.Number s.Usings s.Mode e.Index) e.Vars-E
  (#CmdInsertVar s.Usings s.Mode e.Index) =
    (#CmdInsertVar s.Mode s.Number);

  e.Vars t.OtherCommand =
    t.OtherCommand;
}

MakeCopyVar {
  e.Vars-B (s.Number s.Usings s.Mode e.Index) e.Vars-E
  (s.Usings s.Mode e.Index) =
    <Fetch
      e.Vars-B e.Vars-E <Dec s.Usings>
      {
        e.Vars-B^ (s.Sample s.Usings-1 s.Mode e.Index) e.Vars-E^ s.Usings-1 =
          (#CmdCopyVar s.Mode s.Number s.Sample);
      }
    >;
}

PatchVariableNumbers {
  (e.CommonVars) e.Commands =
    <Fetch
      e.Commands
      <Seq
        (MapReduce
          PatchVariableNumber
          (e.CommonVars)
        )
        {
          (e.CommonVars^) e.Commands^ =
            <Map MakeVariableComment e.CommonVars>
            e.Commands;
        }
      >
    >;
}

MakeVariableComment {
  (s.Number s.Usings s.Mode e.Index s.Depth) =
    (#CmdComment
      <StrFromInt s.Number> ': '
      s.Mode '.'  e.Index '#' <StrFromInt s.Depth> '/' <StrFromInt s.Usings>
    );
}

PatchVariableNumber {
  (e.Vars-B (s.Number s.Usings s.Mode e.Index) e.Vars-E)
  (#CmdRepeated s.Direction s.BracketNumber s.Usings s.Mode e.Index) =
    <Fetch
      <Dec s.Usings>
      e.Vars-B
      {
        s.SampleUsings
        e.Vars-BB (s.SampleNumber s.SampleUsings s.Mode e.Index) e.Vars-BE =
          (
            e.Vars-BB (s.SampleNumber s.SampleUsings s.Mode e.Index)
            e.Vars-BE (s.Number s.Usings s.Mode e.Index)
            e.Vars-E
          )
          (#CmdRepeated
            s.Direction s.BracketNumber s.Mode s.Number s.SampleNumber
          );
      }
    >;

  (e.Vars-B (s.VarNumber 1 'e' e.Index) e.Vars-E)
  (#CmdClosedE #AlgLeft s.BracketNumber 'e' e.Index) =
    (e.Vars-B (s.VarNumber 1 'e' e.Index) e.Vars-E)
    (#CmdClosedE #AlgLeft s.BracketNumber s.VarNumber);

  (e.Vars-B (s.VarNumber 1 'e' e.Index) e.Vars-E)
  (#CmdOpenedE #AlgLeft s.BracketNumber 'e' e.Index) =
    (e.Vars-B (s.VarNumber 1 'e' e.Index) e.Vars-E)
    (#CmdOpenedE #AlgLeft s.BracketNumber s.VarNumber);

  (e.Vars-B (s.VarNumber 1 s.Mode e.Index) e.Vars-E)
  (#CmdVar s.Direction s.BracketNumber s.Mode e.Index) =
    (e.Vars-B (s.VarNumber 1 s.Mode e.Index) e.Vars-E)
    (#CmdVar s.Direction s.BracketNumber s.Mode s.VarNumber);

  (e.Vars) t.NextCommand = (e.Vars) t.NextCommand;
}

/*
  e.Vars ::= (s.Count s.Mode e.Index)*
*/

//==============================================================================
// Генерация образца
//==============================================================================

/*
Команды распознавания
  Литералы, формат (#Cmd*** s.Direction s.BracketNum e.Literal)
  Скобки, формат (#CmdBrackets s.Direction s.BracketNum s.InnerNum)
  АТД, формат
    (#CmdADT s.Direction s.BracketNum s.InnerNum e.Name)
  Пустые скобки, формат (#CmdEmpty #AlgLeft s.BracketNum),
    направление добавлено для единнобразия, генератором не используется
  Переменные:
    повторные, формат
      (#CmdRepeated s.Direction s.BracketNum s.Mode s.VarNumber s.SampleNumber)
    новые s и t, формат (#CmdVar s.Direction s.BracketNum s.Mode s.VarNumber)
    открытые e:
      первоначальный формат (#CmdOpenedE #AlgLeft s.BracketNum s.VarNumber)
      после обработки:
        (#CmdOpenedE-Start #AlgLeft s.BracketNum 'e' e.Index)
        (#CmdOpenedE-End #AlgLeft s.BracketNum 'e' e.Index)
    закрытые e, формат
      (#CmdClosedE #AlgLeft s.BracketNum 'e' e.Index (e.BracketsForSave))
  Команды сохранения скобок
    (#CmdSave s.OldNumber e.NewNumber)
  Комментарий, вносимый в исходный код (#CmdComment e.Text)
*/

GenPattern {
  e.Pattern =
    <Fetch
      <DoGenPattern
        2 (#Junk) (#Range 0 e.Pattern) (#Junk) (/* vars */) (/* commands */)
      >
      <Seq
        {
          s.ContextOffset (e.Vars) (e.MarkedPattern) e.Commands =
            (e.Vars) (e.MarkedPattern)
            <SaveBrackets s.ContextOffset e.Commands>;
        }
        {
          (e.Vars) (e.MarkedPattern) s.ContextOffset e.Commands =
            (e.Vars)
            s.ContextOffset
            ((#CmdComment <TextFromPattern e.MarkedPattern>) e.Commands);
        }
      >
    >;
}

Inc2 {
  s.Num = <Add 2 s.Num>;
}

DoGenPattern {
  // Распознавание литералов (символьных, целочисленных, имён)
  s.ContextOffset
  e.Ranges-B (#Junk e.Junk) (#Range s.Num (#TkChar s.Char) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Junk e.Junk (#TkChar s.Char)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdChar #AlgLeft s.Num s.Char))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkNumber s.Number) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Junk e.Junk (#TkNumber s.Number)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdNumber #AlgLeft s.Num s.Number))
    >;

  s.ContextOffset
  e.Ranges-B (#Junk e.Junk) (#Range s.Num (#TkName e.Name) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B (#Junk (#TkName e.Name)) (#Range s.Num e.Range) e.Ranges-E
      (e.Vars) (e.Commands (#CmdName #AlgLeft s.Num e.Name))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkIdentifier e.Name) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Junk e.Junk (#TkIdentifier e.Name)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdIdent #AlgLeft s.Num e.Name))
    >;

  s.ContextOffset
  e.Ranges-B (#Range s.Num e.Range (#TkChar s.Char)) (#Junk e.Junk) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkChar s.Char) e.Junk)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdChar #AlgRight s.Num s.Char))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#TkNumber s.Number)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkNumber s.Number) e.Junk)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdNumber #AlgRight s.Num s.Number))
    >;

  s.ContextOffset
  e.Ranges-B (#Range s.Num e.Range (#TkName e.Name)) (#Junk e.Junk) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkName e.Name) e.Junk)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdName #AlgRight s.Num e.Name))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#TkIdentifier e.Name)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkIdentifier e.Name) e.Junk)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdIdent #AlgRight s.Num e.Name))
    >;

  // Распознавание скобок
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#Brackets e.SubRange) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc2 s.ContextOffset>
      e.Ranges-B
      (#Junk e.Junk (#TkOpenBracket)) (#Range s.ContextOffset e.SubRange)
      (#Junk (#TkCloseBracket)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdBrackets #AlgLeft s.Num s.ContextOffset))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#Brackets e.SubRange)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc2 s.ContextOffset>
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkOpenBracket))
      (#Range s.ContextOffset e.SubRange) (#Junk (#TkCloseBracket) e.Junk)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdBrackets #AlgRight s.Num s.ContextOffset))
    >;

  // Распознавание АТД-скобок
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#ADT-Brackets (e.Name) e.SubRange) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc2 s.ContextOffset>
      e.Ranges-B
      (#Junk e.Junk (#TkOpenADT) (#TkName e.Name))
      (#Range s.ContextOffset e.SubRange)
      (#Junk (#TkCloseADT)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars)
      (e.Commands (#CmdADT #AlgLeft s.Num s.ContextOffset e.Name))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#ADT-Brackets (e.Name) e.SubRange)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc2 s.ContextOffset>
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkOpenADT) (#TkName e.Name))
      (#Range s.ContextOffset e.SubRange) (#Junk (#TkCloseADT) e.Junk)
      e.Ranges-E
      (e.Vars)
      (e.Commands (#CmdADT #AlgRight s.Num s.ContextOffset e.Name))
    >;

  // Пустой диапазон
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk1) (#Range s.Num /* пусто */) (#Junk e.Junk2)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B (#Junk e.Junk1 e.Junk2) e.Ranges-E
      (e.Vars) (e.Commands (#CmdEmpty #AlgLeft s.Num))
    >;

  // Распознавание переменных
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkVariable s.Mode e.Index) e.Range)
  e.Ranges-E
  (e.Vars-B (s.Count s.Mode e.Index) e.Vars-E) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Junk e.Junk (#TkVariable s.Mode e.Index)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars-B (<Inc s.Count> s.Mode e.Index) e.Vars-E)
      (e.Commands (#CmdRepeated #AlgLeft s.Num <Inc s.Count> s.Mode e.Index))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#TkVariable s.Mode e.Index)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars-B (s.Count s.Mode e.Index) e.Vars-E) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkVariable s.Mode e.Index) e.Junk)
      e.Ranges-E
      (e.Vars-B (<Inc s.Count> s.Mode e.Index) e.Vars-E)
      (e.Commands (#CmdRepeated #AlgRight s.Num <Inc s.Count> s.Mode e.Index))
    >;

  // Диапазон с закрытой переменной
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk1) (#Range s.Num (#TkVariable 'e' e.Index)) (#Junk e.Junk2)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B (#Junk e.Junk1 (#TkVariable 'e' e.Index) e.Junk2) e.Ranges-E
      (e.Vars (1 'e' e.Index))
      (e.Commands (#CmdClosedE #AlgLeft s.Num 'e' e.Index))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkVariable 's' e.Index) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Junk e.Junk (#TkVariable 's' e.Index)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars (1 's' e.Index)) (e.Commands (#CmdVar #AlgLeft s.Num 's' e.Index))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkVariable 't' e.Index) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Junk e.Junk (#TkVariable 't' e.Index)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars (1 't' e.Index)) (e.Commands (#CmdVar #AlgLeft s.Num 't' e.Index))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#TkVariable 's' e.Index)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkVariable 's' e.Index) e.Junk)
      e.Ranges-E
      (e.Vars (1 's' e.Index)) (e.Commands (#CmdVar #AlgRight s.Num 's' e.Index))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#TkVariable 't' e.Index)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkVariable 't' e.Index) e.Junk)
      e.Ranges-E
      (e.Vars (1 't' e.Index)) (e.Commands (#CmdVar #AlgRight s.Num 't' e.Index))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkVariable 'e' e.Index) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Junk e.Junk (#TkVariable 'e' e.Index)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars (1 'e' e.Index))
      (e.Commands (#CmdOpenedE #AlgLeft s.Num 'e' e.Index))
    >;

  // Завершение разбора.
  s.ContextOffset (#Junk e.MarkedPattern) (e.Vars) (e.Commands) =
    s.ContextOffset (e.Vars) (e.MarkedPattern) e.Commands;
}

SaveBrackets {
  s.LastBracket e.Commands = <DoSaveBrackets s.LastBracket () e.Commands>;
}

DoSaveBrackets {
  s.LastBracket (e.Scanned)
  e.Commands-B (#CmdOpenedE #AlgLeft s.Num 'e' e.Index) e.Commands-E =
    <Fetch
      e.Scanned e.Commands-B (#CmdOpenedE #AlgLeft s.Num 'e' e.Index)
      {
        e.CommandsBeforeEMatch =
          <DoSaveBrackets-MakeSavers
            s.LastBracket
            ( <ExtractBrackets e.CommandsBeforeEMatch> )
            ( e.CommandsBeforeEMatch )
            e.Commands-E
          >;
      }
    >;

  s.LastBracket (e.Scanned) e.Commands = s.LastBracket e.Scanned e.Commands;
}

DoSaveBrackets-MakeSavers {
  s.LastBracket
  (e.BoundedBrackets-B s.Num e.BoundedBrackets-E)
  (e.Scanned)
  e.Commands-B (s.Command s.Direction s.Num e.Args) e.Commands-E =
    <DoSaveBrackets-MakeSavers
      <Inc2 s.LastBracket>
      (e.BoundedBrackets-B e.BoundedBrackets-E)
      (e.Scanned (#CmdSave s.Num s.LastBracket))
      <Map
        {
          /*
            Все команды распознавания содержат номер скобок третьим термом,
            общий формат (s.Command s.Direction s.BracketNum e.Info)
          */
          (s.Command^ s.Direction^ s.Num e.Info^) =
            (s.Command s.Direction s.LastBracket e.Info);

          (s.Command^ s.Direction^ s.OtherNum e.Info^) =
            (s.Command s.Direction s.OtherNum e.Info);
        }
        e.Commands-B (s.Command s.Direction s.Num e.Args) e.Commands-E
      >
    >;

  s.LastBracket (e.UnusedBoundedBrackets) (e.Scanned) e.Commands =
    <DoSaveBrackets s.LastBracket (e.Scanned) e.Commands>;
}

ExtractBrackets {
  e.Commands =
    <Brackets-Set
      <Map
        {
          /*
            Все команды распознавания содержат номер скобок третьим термом,
            общий формат (s.Command s.Direction s.BracketNum e.Info)
          */
          (#CmdBrackets s.Direction s.BracketNum s.InnerNum) =
            s.BracketNum s.InnerNum;

          (#CmdADT s.Direction s.BracketNum s.InnerNum e.Name) =
            s.BracketNum s.InnerNum;

          (s.Command s.Direction s.BracketNum e.Info) = s.BracketNum;
        }
        e.Commands
      >
    >;
}

Brackets-Set {
  e.Unique s.Repeated e.Middle s.Repeated e.Rest =
    e.Unique <Brackets-Set s.Repeated e.Middle e.Rest>;

  e.Unique = e.Unique;
}

TextFromPattern {
  (#TkOpenBracket) e.Tail = ' (' <TextFromPattern e.Tail>;
  (#TkCloseBracket) e.Tail = ' )' <TextFromPattern e.Tail>;

  (#TkOpenADT) (#TkName e.Name) e.Tail = ' [' e.Name <TextFromPattern e.Tail>;
  (#TkCloseADT) e.Tail = ' ]' <TextFromPattern e.Tail>;

  (#TkChar s.Char) e.Tail =
    ' ' '' <TextFromPattern-Char (#TkChar s.Char) e.Tail>;

  (#TkNumber s.Number) e.Tail =
    ' ' <StrFromInt s.Number> <TextFromPattern e.Tail>;

  (#TkName e.Name) e.Tail =
    ' & ' e.Name <TextFromPattern e.Tail>;

  (#TkVariable s.Mode e.Index s.Depth) e.Tail =
    ' ' s.Mode '.' e.Index '#' <StrFromInt s.Depth> <TextFromPattern e.Tail>;

  (#TkIdentifier e.Name) e.Tail =
    ' # ' e.Name <TextFromPattern e.Tail>;

  = ;
}

Escape {
  s.Char = <EscapeChar s.Char>;
}

TextFromPattern-Char {
  (#TkChar s.Char) e.Tail =
    <Escape s.Char> <TextFromPattern-Char e.Tail>;

  e.Other = '' <TextFromPattern e.Other>;
}

//==============================================================================
// Генерация результата
//==============================================================================

GenResult {
  s.BaseContextSize e.Result =
    <DoGenResult
      (/* vars */)
      (/* alloc commands */) (/* other commands */)
      s.BaseContextSize // счётчик новых элементов
      <CollectStrings e.Result>
    >;
}

CollectStrings {
  (#TkChar s.Value1) (#TkChar s.Value2) e.Tail =
    <Fetch
      <BuildString (s.Value1 s.Value2) e.Tail>
      {
        (e.Chars) e.Tail^ = (#TkString e.Chars) <CollectStrings e.Tail>;
      }
    >;

  (#Brackets e.InBrackets) e.Tail =
    (#Brackets <CollectStrings e.InBrackets>) <CollectStrings e.Tail>;

  (#CallBrackets e.InBrackets) e.Tail =
    (#CallBrackets <CollectStrings e.InBrackets>) <CollectStrings e.Tail>;

  (#ADT-Brackets e.InBrackets) e.Tail =
    (#ADT-Brackets <CollectStrings e.InBrackets>) <CollectStrings e.Tail>;

  t.OtherTerm e.Tail = t.OtherTerm <CollectStrings e.Tail>;

  /* пусто */ = /* пусто */;
}

BuildString {
  (e.Chars) (#TkChar s.Value) e.Tail =
    <BuildString (e.Chars s.Value) e.Tail>;

  (e.Chars) e.Tail = (e.Chars) e.Tail;
}

// Основные команды работы с образцом
//  (#CmdAllocateElem s.Number s.ElType e.Info)
//  (#CmdLinkBrackets s.Left s.Right)
//  (#CmdPushStack s.Number)
//  (#CmdInsertElem s.Number)
//  (#CmdInsertVar s.Mode s.Number)

/*
  Порядок выполнения команд.
  1. Все выделения памяти (в порядке перечисления)
  2. Связывание крулых и угловых скобок и
  построение результата (в обратном порядке)
*/

DoGenResult {
  // Создаём литералы
  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter (#TkChar s.Value) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElChar s.Value))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter (#TkName e.Name) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElName e.Name))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkNumber s.Number) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElNumber s.Number))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkIdentifier e.Name) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElIdent e.Name))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkString e.Chars) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElString e.Chars))
      ((#CmdInsertRange s.Counter) e.Commands)
      <Add s.Counter 2> e.Result
    >;

  /*
    Обработка открывающих скобок всех трёх типов осуществляется похоже.
  */
  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#Brackets e.InBrackets) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElOpenBracket))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.InBrackets (#TkCloseBracket s.Counter) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#CallBrackets e.InBrackets) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElOpenCall))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter> e.InBrackets (#CloseCall s.Counter) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#ADT-Brackets (e.Name) e.InBrackets) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElOpenADT))
      ((#CmdInsertElem s.Counter) e.Commands)
      <Inc s.Counter>
      (#TkName e.Name) e.InBrackets (#TkCloseADT s.Counter) e.Result
    >;

  /*
    Закрывающие скобки надо обрабатывать особым образом.
    Круглые скобки и АТД -- слинковать, угловые -- добавить в стек.
  */
  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkCloseBracket s.OpenCounter) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElCloseBracket))
      (
        (#CmdLinkBrackets s.OpenCounter s.Counter)
        (#CmdInsertElem s.Counter)
        e.Commands
      )
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkCloseADT s.OpenCounter) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElCloseADT))
      (
        (#CmdLinkBrackets s.OpenCounter s.Counter)
        (#CmdInsertElem s.Counter)
        e.Commands
      )
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#CloseCall s.OpenCounter) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (#CmdAllocateElem s.Counter #ElCloseCall))
      (
        (#CmdPushStack s.Counter)
        (#CmdPushStack s.OpenCounter)
        (#CmdInsertElem s.Counter)
        e.Commands
      )
      <Inc s.Counter> e.Result
    >;

  // Обработка переменных
  (e.Vars-B (s.Usings s.Mode e.Index) e.Vars-E) (e.AllocCommands) (e.Commands)
  s.Counter (#TkVariable s.Mode e.Index) e.Result =
    <DoGenResult
      (e.Vars-B (<Inc s.Usings> s.Mode e.Index) e.Vars-E)
      (e.AllocCommands)
      ((#CmdInsertVar <Inc s.Usings> s.Mode e.Index) e.Commands)
      s.Counter e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (#TkVariable s.Mode e.Index) e.Result =
    <DoGenResult
      (e.Vars (1 s.Mode e.Index))
      (e.AllocCommands)
      ((#CmdInsertVar 1 s.Mode e.Index) e.Commands)
      s.Counter e.Result
    >;

  // Завершение просмотра
  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter =
    s.Counter (e.Vars) (e.AllocCommands e.Commands);
}
