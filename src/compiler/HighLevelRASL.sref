//FROM LibraryEx
$EXTERN Map, Fetch, Seq, MapReduce, Compare;

//FROM HighLevelRASL-GenResult-Simple
$EXTERN GenResult-Simple;

//FROM HighLevelRASL-GenSubst-Simple
$EXTERN GenInitSubst-Simple, GenSubst-Simple;

/**
  <HighLevelRASL e.AST>
    == e.RASLAST

  e.RASLAST ::= t.RASLFunction*
  t.RASLFunction ::=
      (#Function s.ScopeClass (e.Name) t.HiRASLCommand*)
    | (s.SingularItem s.ScopeClass e.Name)
    | (#Ident e.Name)
    | (#Separator)
  s.SingularItem ::= #Enum | #Swap | #Stub | #Declaration
  t.HiRASLCommand ::=
      (#Cmd… e.Value)
    | (#CmdSentence t.HiRASLCommand*)
    | (#CmdOpenELoop #AlgLeft s.BracketNum s.VarNumber t.HiRASLCommand*)
*/
$ENTRY HighLevelRASL {
  e.ProgramElements =
    <Map
      {
        (#Function s.ScopeClass (e.Name) e.Sentences) =
          <HighLevelRASL-Function
            s.ScopeClass (e.Name) e.Sentences
          >;

        (#Enum s.ScopeClass e.Name) =
          (#CmdEnum s.ScopeClass e.Name);

        (#Swap s.ScopeClass e.Name) =
          (#CmdSwap s.ScopeClass e.Name);

        (#Stub s.ScopeClass e.Name) =
          /* пусто */;

        (#Declaration s.ScopeClass e.Name) =
          (#CmdDeclaration s.ScopeClass e.Name);

        (#Ident e.Name) = (#CmdDefineIdent e.Name);

        (#Separator) = (#CmdSeparator);
      }
      e.ProgramElements
    >;
}

HighLevelRASL-Function {
  s.ScopeClass (e.Name) e.Sentences =
    <Fetch
      e.Sentences
      <Seq
        (Map
          {
            ((e.Pattern) (e.Result)) =
              (<HighLevelRASL-Sentence e.Name (e.Pattern) (e.Result)>);
          }
        )
        (MapReduce
          {
            s.MaxMemory ((#CmdIssueMem s.Memory) e.Sentence) =
              <Fetch
                <Compare s.MaxMemory s.Memory> {
                  '<' = s.Memory;
                  s.Other = s.MaxMemory;
                }
              >
              (#CmdSentence e.Sentence);
          }
          0
        )
        {
          s.MaxMemory e.Sentences^ (#CmdSentence e.LastSentence) =
            (#Function
              s.ScopeClass (e.Name)
              (#CmdIssueMem s.MaxMemory)
              e.Sentences
              <Fetch
                e.LastSentence
                {
                  e.Commands (#CmdOpenELoop e.OpenELoop) =
                    e.Commands (#CmdOpenELoop e.OpenELoop) (#CmdFail);

                  e.LastSentence^ = e.LastSentence;
                }
              >
            );

          0 /* нет предложений */ =
            (#CmdEnum s.ScopeClass e.Name);
        }
      >
    >;
}

HighLevelRASL-Sentence {
  e.Name (e.Pattern) (e.Result) =
    <Fetch
      <GenPattern (e.Name) e.Pattern>
      {
        s.ContextOffset (e.PatternVars) (e.MarkedPattern) e.PatternCommands =
          <Fetch
            <GenResult-Simple
              s.ContextOffset (e.PatternVars) (e.MarkedPattern) e.Result
            >
            {
              s.ContextCount e.ResultCommands =
                <FoldOpenELoops
                  (#CmdIssueMem s.ContextCount)
                  e.PatternCommands
                  e.ResultCommands
                >;
            }
          >;
      }
    >;
}

FoldOpenELoops {
  e.Commands-B (#CmdOpenedE #AlgLeft s.BracketNum s.VarNumber) e.Commands-E =
    e.Commands-B
    (#CmdOpenELoop
      #AlgLeft s.BracketNum s.VarNumber
      <FoldOpenELoops e.Commands-E>
    );

  e.Commands = e.Commands;
}

/*
  e.Vars ::= (s.Count s.Mode e.Index)*
*/

//==============================================================================
// Генерация образца
//==============================================================================

/*
Команды распознавания
  Литералы, формат (#Cmd*** s.Direction s.BracketNum e.Literal)
  Скобки, формат (#CmdBrackets s.Direction s.BracketNum s.InnerNum)
  АТД, формат
    (#CmdADT s.Direction s.BracketNum s.InnerNum e.Name)
  Пустые скобки, формат (#CmdEmpty #AlgLeft s.BracketNum),
    направление добавлено для единнобразия, генератором не используется
  Переменные:
    повторные, формат
      (#CmdRepeated s.Direction s.BracketNum s.Mode s.VarNumber s.SampleNumber)
    новые s и t, формат (#CmdVar s.Direction s.BracketNum s.Mode s.VarNumber)
    открытые e:
      первоначальный формат (#CmdOpenedE #AlgLeft s.BracketNum s.VarNumber)
      после обработки:
        (#CmdOpenedE-Start #AlgLeft s.BracketNum 'e' e.Index)
        (#CmdOpenedE-End #AlgLeft s.BracketNum 'e' e.Index)
  Команды сохранения скобок
    (#CmdSave s.OldNumber e.NewNumber)
  Комментарий, вносимый в исходный код (#CmdComment e.Text)
*/

GenPattern {
  (e.Name) e.Pattern =
    <Fetch
      <GenInitSubst-Simple e.Name>
      {
        s.B0-Offset s.ContextTop
        (#Junk e.JunkLeft) (#Junk e.JunkRight) e.InitCommands =
          <GenSubst-Simple
            s.ContextTop
            (#Junk e.JunkLeft) (#E s.B0-Offset e.Pattern) (#Junk e.JunkRight)
            (e.InitCommands)
          >;
      }
    >;
}
