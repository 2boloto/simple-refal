//FROM LibraryEx
$EXTERN Fetch, Seq, SaveFile, Map, SaveBytes;

//FROM LoadSource
$EXTERN LoadSource;

//FROM Lexer
$EXTERN LexFolding;

//FROM Parser
$EXTERN ParseProgram;

//FROM Error
$EXTERN EL-Create, EL-Destroy;

//FROM Checker
$EXTERN CheckProgram;

//FROM Desugaring
$EXTERN Desugar;

//FROM HighLevelRASL
$EXTERN HighLevelRASL;

//FROM LowLevelRASL
$EXTERN LowLevelRASL;

//FROM Generator-RASL
$EXTERN GenProgram-RASL;

//FROM Library
$EXTERN StrFromInt;

//FROM Generator-Native
$EXTERN GenProgram-Native;

/**
  <CompileFile s.GenMode s.Opt s.MarkupContext (e.SrcName) e.OutputName>
    == #Success e.OutputName t.Native
    == #Fails

  s.GenMode ::= #OnlyDirect | #OnlyInterpret | #Both
  s.Opt ::= #OptNone | #OptPattern | #OptResult | #OptBoth
  s.MarkupContext ::= #MarkupContext | #NoMarkupContext
  t.Native ::= #NoNative | (e.NativeOutputName)
*/
$ENTRY CompileFile {
  s.GenMode s.Opt s.MarkupContext (e.SrcName) e.OutputName '.rasl' =
    <Fetch
      e.SrcName
      <Seq
        <FrontEnd e.SrcName>
        {
          t.ErrorList e.AST =
            <Fetch
              <EL-Destroy t.ErrorList>
              {
                #EL-NoErrors =
                  <Fetch
                    e.AST
                    <BackEnd
                      s.MarkupContext s.Opt s.GenMode (e.SrcName) e.OutputName
                    >
                  >;

                #EL-HasErrors =
                  #Fails;
              }
            >;
        }
      >
    >;
}

FrontEnd {
  e.SrcName =
    <Seq
      LoadSource
      LexFolding
      (ParseProgram <EL-Create e.SrcName>)
      {
        t.ErrorList e.AST =
          <CheckProgram t.ErrorList e.AST>
          e.AST;
      }
    >;
}

BackEnd {
  s.MarkupContext s.Opt s.GenMode (e.SrcName) e.OutputName =
    <Seq
      (Desugar s.MarkupContext)
      (HighLevelRASL <SelectOptFlags s.Opt>)
      (LowLevelRASL s.GenMode (e.SrcName))
      {
        t.RASLModule =
          <BackEnd-RASLModule t.RASLModule e.OutputName '.rasl'>
          #NoNative;

        t.RASLModule t.NativeModule =
          <BackEnd-RASLModule t.RASLModule e.OutputName '.rasl'>
          <BackEnd-NativeModule
            t.NativeModule (e.SrcName) e.OutputName '.cpp'
          >;
      }
    >;
}

BackEnd-RASLModule {
  t.RASLModule e.OutputName =
    <Fetch
      <GenProgram-RASL t.RASLModule>
      {
        e.ByteStream =
        <SaveFile (e.OutputName '.cpp') <EnvelopeCLines e.ByteStream>>
        <SaveBytes (e.OutputName) e.ByteStream>;
      }
    >
    #Success e.OutputName;
}

// Грязный хак, но так надо
EnvelopeCLines {
  e.Bytes =
    ('// Automatically generated file. Don\'t edit!')
    ('#include "refalrts.h"')
    ()
    ('static unsigned char bytes[] = {')
    <Map
      {
        s.Number =
          ('  ' <StrFromInt s.Number> ',');
      }
      e.Bytes
    >
    ('  0')
    ('};')
    ()
    ('static refalrts::RawBytesBlock block(bytes, sizeof(bytes) - 1);')
    ()
    ('//End of file');
}

BackEnd-NativeModule {
  t.NativeModule (e.SrcName) e.OutputName =
    <SaveFile
      (e.OutputName)
      <GenProgram-Native (e.SrcName) (e.OutputName) t.NativeModule>
    >
    (e.OutputName);
}

SelectOptFlags {
  #OptNone    = #Disjoint #NoOpt;
  #OptPattern = #Conjoint #NoOpt;
  #OptResult  = #Disjoint #OptResult;
  #OptBoth    = #Conjoint #OptResult;
}
