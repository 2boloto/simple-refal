//FROM LibraryEx
$EXTERN Map, Fetch, Seq, MapReduce, Compare, DelAccumulator;

//FROM HardSent
$EXTERN CreateHardPattern;

//FROM GlobalGen
$EXTERN CreateGlobalGen, SplitGen, Max, PatternComment, ReverseGen;

//FROM HighLevelRASL-Common
$EXTERN FoldOpenELoops;

$ENTRY HighLevelRASL-Function-Conjoint {
  s.FnGenInitSubst s.FnGenSubst s.FnGenResult
  s.ScopeClass (e.Name) t.OneSentence =
    <HighLevelRASL-OneFunction
      s.FnGenInitSubst s.FnGenSubst s.FnGenResult
      s.ScopeClass (e.Name) t.OneSentence
    >;

  s.FnGenInitSubst s.FnGenSubst s.FnGenResult
  s.ScopeClass (e.Name) e.Sentences =
    <HighLevelRASL-MulFunction
      s.FnGenInitSubst s.FnGenSubst s.FnGenResult
      s.ScopeClass (e.Name) e.Sentences
    >;
}

HighLevelRASL-OneFunction {
  s.FnGenInitSubst s.FnGenSubst s.FnGenResult
  s.ScopeClass (e.Name) e.Sentences =
    <Fetch
      e.Sentences
      <Seq
        {
          ((e.Pattern) (e.Result)) =
            (
              <HighLevelRASL-Sentence
                s.FnGenInitSubst s.FnGenSubst s.FnGenResult
                (e.Name) (e.Pattern) (e.Result)
              >
            );
        }
        (MapReduce
          {
            s.MaxMemory ((#CmdIssueMem s.Memory) e.Sentence) =
              <Fetch
                <Compare s.MaxMemory s.Memory> {
                  '<' = s.Memory;
                  s.Other = s.MaxMemory;
                }
              >
              (#CmdSentence e.Sentence);
          }
          0
        )
        {
          s.MaxMemory e.Sentences^ (#CmdSentence e.LastSentence) =
            (#Function
              s.ScopeClass (e.Name)
              (#CmdIssueMem s.MaxMemory)
              e.Sentences
              <Fetch
                e.LastSentence
                {
                  e.Commands (#CmdOpenELoop e.OpenELoop) =
                    e.Commands (#CmdOpenELoop e.OpenELoop) (#CmdFail);

                  e.LastSentence^ = e.LastSentence;
                }
              >
            );

          0 /* нет предложений */ =
            (#CmdEnum s.ScopeClass e.Name);
        }
      >
    >;
}

HighLevelRASL-Sentence {
  s.FnGenInitSubst s.FnGenSubst s.FnGenResult
  (e.Name) (e.Pattern) (e.Result) =
    <Fetch
      <GenPattern s.FnGenInitSubst s.FnGenSubst (e.Name) e.Pattern>
      {
        s.ContextOffset (e.PatternVars) (e.MarkedPattern) e.PatternCommands =
          <Fetch
            <s.FnGenResult
              s.ContextOffset (e.PatternVars) (e.MarkedPattern) e.Result
            >
            {
              s.ContextCount e.ResultCommands =
                <FoldOpenELoops
                  (#CmdIssueMem s.ContextCount)
                  e.PatternCommands
                  e.ResultCommands
                >;
            }
          >;
      }
    >;
}

GenPattern {
  s.FnGenInitSubst s.FnGenSubst (e.Name) e.Pattern =
    <Fetch
      <s.FnGenInitSubst e.Name>
      {
        s.B0-Offset s.ContextTop
        (#Junk e.JunkLeft) (#Junk e.JunkRight) e.InitCommands =
          <s.FnGenSubst
            s.ContextTop
            (#Junk e.JunkLeft) (#E s.B0-Offset e.Pattern) (#Junk e.JunkRight)
            (e.InitCommands)
          >;
      }
    >;
}
HighLevelRASL-MulFunction {
  s.FnGenInitSubst s.FnGenSubst s.FnGenResult
  s.ScopeClass (e.Name) e.Sentences =
    <Fetch
      e.Sentences
      <Seq
        (MapReduce
          {
            (e.HardGens) ((e.Pattern) (e.Result)) =
              <Fetch
                <CreateHardPattern e.Pattern>
                {
                  e.HardGen =
                    (e.HardGens (e.HardGen))
                    ((<PatternComment e.HardGen>) (e.Result));
                }
              >;
          }
          (/* hard gens */)
        )
        {
          (e.HardPatterns) e.SentenceTails =
            <CreateGlobalGen e.HardPatterns> e.SentenceTails;
        }
        {
          (e.FastGen) (e.GlobalGen) e.SentenceTails =
            (
              (#CmdComment 'FAST GEN:' <PatternComment e.FastGen>)
              (#CmdComment 'GLOBAL GEN:' <PatternComment e.GlobalGen>)
            )
            (<SplitGen (e.GlobalGen) e.SentenceTails>)
            e.SentenceTails;
        }
        {
          (e.Comments) ((e.CommonPattern) e.SentSubsts) e.SentenceTails =
            (e.Comments)
            (
              <GenPattern
                s.FnGenInitSubst s.FnGenSubst (e.Name)
                <ReverseGen e.CommonPattern>
              >
            )
            <DelAccumulator
              <MapReduce
                {
                  ((e.Substitute) e.Substs) ((e.HardGenComment) (e.Result)) =
                    (e.Substs)
                    ((e.Substitute) (e.HardGenComment) (e.Result));
                }
                (e.SentSubsts) e.SentenceTails
              >
            >;
        }
        {
          (e.Comments)
          (s.ContextSize (e.Vars) (e.MarkedPattern) e.CommonMatchCommands)
          e.SentencesWithSubst =
            (e.Comments e.CommonMatchCommands)
            <MapReduce
              {
                s.MaxMemory ((e.Substitute) (e.HardGenComment) (e.Result)) =
                  <Fetch
                    <GenSentence
                      s.FnGenInitSubst s.FnGenSubst s.FnGenResult
                      s.ContextSize (e.Vars) (e.Substitute) (e.Result)
                    >
                    {
                      (#CmdIssueMem s.Memory) e.Commands =
                        <Max s.MaxMemory s.Memory>
                        (#CmdSentence
                          (#CmdComment e.HardGenComment)
                          e.Commands
                        );
                    }
                  >;
              }
              s.ContextSize e.SentencesWithSubst
            >;
        }
        {
          (e.Prefix) s.MaxMemory e.Sentences^ (#CmdSentence e.LastSentence) =
            (#Function
              s.ScopeClass (e.Name)
              (#CmdIssueMem s.MaxMemory)
              e.Prefix
              e.Sentences
              <Fetch
                e.LastSentence
                {
                  e.Commands (#CmdOpenELoop e.OpenELoop) =
                    e.Commands (#CmdOpenELoop e.OpenELoop) (#CmdFail);
                  e.LastSentence^ = e.LastSentence;
                }
              >
            );

          (e.Prefix) 0 /* нет предложений */ =
            (#CmdEnum s.ScopeClass e.Name);
        }
      >
    >;
}

GenSentence {
  s.FnGenInitSubst s.FnGenSubst s.FnGenResult
  s.ContextSize (e.Vars) (e.Substitute) (e.Result) =
    <Fetch
      s.ContextSize (e.Vars) (e.Substitute) (e.Result)
      <Seq
        // 1. (e.Vars) (e.Substitute) => (e.PrepSubstitute)
        {
          e.Head (e.Vars) (e.Substitute) e.Tail =
            e.Head
            <ComposeVars (/* Scanned */) (e.Substitute) (e.Vars)>
            e.Tail;
        }
        // 2. #E #CmdSave — removed
        // 3. GenSubst-Simple
        // 3.1. GenResult-Simple
        {
          s.MaxMemory (e.Substitutes) (e.Result^) =
            <Fetch
              <s.FnGenSubst
                s.MaxMemory
                (#Junk)
                <Map
                  {
                    t.Subst = t.Subst (#Junk);
                  }
                  e.Substitutes
                >
                (/* commands */)
              >
              {
                s.ContextOffset (e.PatternVars) (e.MarkedPattern)
                e.PatternCommands =
                  <Fetch
                    <s.FnGenResult
                      s.ContextOffset (e.PatternVars) (e.MarkedPattern) e.Result
                    >
                    {
                      s.ContextCount e.ResultCommands =
                        <FoldOpenELoops
                          (#CmdIssueMem <Max s.MaxMemory s.ContextCount>)
                          e.PatternCommands
                          e.ResultCommands
                        >;
                    }
                  >;
              }
            >;
        }
      >
    >;
}

ComposeVars {
  (e.Scanned)
  (e.Substitute-B (s.Tag (e.Name) '$' e.Subst) e.Substitute-E)
  (e.Vars-B (s.Mode (e.Name) s.Offset) e.Vars-E) =
    <ComposeVars
      (e.Scanned (s.Tag s.Offset e.Subst))
      (e.Substitute-B e.Substitute-E) (e.Vars-B e.Vars-E)
    >;
  (e.Scanned) () () = (e.Scanned);
}
