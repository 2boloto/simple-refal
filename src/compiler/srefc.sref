//FROM LibraryEx
$EXTERN ArgList, LoadFile, Map, SaveFile, Fetch, Seq, DelAccumulator, MapReduce,
  Inc;

//FROM ParseCmdLine
$EXTERN ParseCommandLine;

//FROM Library
$EXTERN WriteLine, StrFromInt, Exit, System, ExistFile, RemoveFile, RenameFile;

//FROM FindFile
$EXTERN FindFiles;

//FROM Driver
$EXTERN CompileFile;

//------------------------------------------------------------------------------

$ENTRY Go {
  = <Main <ArgList>>;
}

Main {
  (e.ProgName) ('@' e.Config) =
    <Main-SwValidCommandLine
      (e.Config) <ParseCommandLine <LoadFile e.Config>>
    >;

  (e.ProgName) e.Arguments =
    <Main-SwValidCommandLine
      #CommandLine <ParseCommandLine e.Arguments>
    >;
}

Main-SwValidCommandLine {
  t.CommandLineSource
  #Success t.CppCompiler s.GenMode s.Opt t.ErrorFile s.MarkupContext
  t.TargetFileName (e.TargetSuffix) (e.Folders) /* файлов нет */ =
    <ReportErrors
      t.CommandLineSource #NoErrorFile (1 'no source files in command line')
    >;

  t.CommandLineSource
  #Success t.CppCompiler s.GenMode s.Opt t.ErrorFile s.MarkupContext
  t.TargetFileName (e.TargetSuffix) (e.Folders) e.Files =
    <Main-SwFoundFiles
      t.CommandLineSource
      t.CppCompiler s.GenMode s.Opt t.ErrorFile s.MarkupContext
      <CalcTargetFileName t.TargetFileName (e.TargetSuffix) e.Files>
      <LookupSourceFiles (e.Folders) e.Files>
    >;

  t.CommandLineSource #Fails e.Errors =
    <ReportErrors t.CommandLineSource #NoErrorFile e.Errors>;
}

ReportErrors {
  #CommandLine t.ErrorFile e.Errors =
    <Map
      {
        (s.Pos e.Message) =
          <WriteLine
            'Command line argument ' <StrFromInt s.Pos> ': Error: ' e.Message
          >;
      }
      e.Errors
    >
    <CreateErrorFileMark t.ErrorFile>
    <Exit 1>;

  (e.ConfigFile) t.ErrorFile e.Errors =
    <Map
      {
        (s.Pos e.Message) =
          <WriteLine
            e.ConfigFile ':' <StrFromInt s.Pos> ': Error: ' e.Message
          >;
      }
      e.Errors
    >
    <CreateErrorFileMark t.ErrorFile>
    <Exit 1>;
}

CreateErrorFileMark {
  #NoErrorFile = /* ничего */;
  (#ErrorFile e.FileName) = <SaveFile (e.FileName)>;
}

Main-SwFoundFiles {
  t.CommandLineSource
  t.CppCompiler s.GenMode s.Opt t.ErrorFile s.MarkupContext (e.TargetFileName)
  e.Files-B (s.Pos #NotFound e.FileName) e.Files-E =
    <ReportErrors
      t.CommandLineSource t.ErrorFile
      <Map
        {
          (s.Pos^ #NotFound e.FileName^) =
            (s.Pos 'file ' e.FileName ' is not found');

          (s.Pos^ #Source (e.Source) e.Output) =
            /* пусто */;

          (s.Pos^ #Output e.Output) =
            /* пусто */;
        }
        (s.Pos #NotFound e.FileName) e.Files-E
      >
    >;

  t.CommandLineSource
  t.CppCompiler s.GenMode s.Opt t.ErrorFile s.MarkupContext (e.TargetFileName)
  e.Files =
    <Main-SwRenamedTargets
      t.CommandLineSource
      t.CppCompiler s.GenMode s.Opt t.ErrorFile s.MarkupContext
      (e.TargetFileName)
      <RenameTargets t.CppCompiler e.Files>
    >;
}

Main-SwRenamedTargets {
  t.CommandLineSource
  t.CppCompiler s.GenMode s.Opt t.ErrorFile s.MarkupContext (e.TargetFileName)
  e.Files-B (s.Pos #Collision e.Collision) e.Files-E =
    <ReportErrors
      t.CommandLineSource t.ErrorFile
      <Map
        {
          (s.Pos^ #Collision (e.FirstTarget) e.SecondTarget) =
            (
              s.Pos
              'files ' e.FirstTarget ' and ' e.SecondTarget ' have same name'
            );

          (s.Pos^ #Source (e.Source) e.Output) =
            /* пусто */;

          (s.Pos^ #Output e.Output) =
            /* пусто */;
        }
        (s.Pos #Collision e.Collision) e.Files-E
      >
    >;

  t.CommandLineSource
  t.CppCompiler s.GenMode s.Opt t.ErrorFile s.MarkupContext (e.TargetFileName)
  e.Files =
    <Main-SwCompiledFiles
      t.CppCompiler t.ErrorFile (e.TargetFileName)
      <CompileFiles s.GenMode s.Opt s.MarkupContext e.Files>
    >;
}

Main-SwCompiledFiles {
  t.CppCompiler t.ErrorFile (e.TargetFileName)
  e.Outputs-B #Fails e.OutputsErrors-E =
    <CreateErrorFileMark t.ErrorFile>
    <Exit 1>;

  t.CppCompiler t.ErrorFile (e.TargetFileName) e.Outputs =
    <Link t.CppCompiler t.ErrorFile (e.TargetFileName) e.Outputs>;
}

//------------------------------------------------------------------------------

CalcTargetFileName {
  (e.TargetFileName) (e.TargetSuffix) e.InputFiles =
    (e.TargetFileName);

  #DefaultTargetFileName (e.TargetSuffix) (s.Pos e.FirstFile) e.OtherFiles =
    <Fetch
      e.FirstFile
      <Seq
        GetLastPartName
        {
          e.LastPartName = (<Lower e.LastPartName>) e.LastPartName;
        }
        {
          (e.LowerBaseName '.sref') e.BaseName '.' s.S s.R s.E s.F =
            e.BaseName;

          (e.LowerBaseName '.cpp') e.BaseName '.' s.C s.P s.P =
            e.BaseName;

          (e.LowerBaseName '.native.cpp')
          e.BaseName '.' s.N s.A s.T s.I s.V s.E '.' s.C s.P s.P =
            e.BaseName;

          (e.LowerBaseName) e.BaseName =
            e.BaseName;
        }
        {
          e.BaseName = (e.BaseName e.TargetSuffix);
        }
      >
    >;
}

LookupSourceFiles {
  (e.Folders) e.Files =
    <Map
      {
        (s.Pos e.FileName) =
          <Fetch
            <FindFiles (e.Folders) (e.FileName)>
            {
              (s.ResultTag e.Info) = (s.Pos s.ResultTag e.Info);
            }
          >;
      }
      e.Files
    >;
}

RenameTargets {
  #NoCppCompiler e.Files = e.Files;

  (e.CppCompiler) e.Files =
    <ScanCollisions <Map GetFileName e.Files>>;
}

GetFileName {
  (s.Pos #Output e.FileName) =
    ((<GetBaseNameLowerCase e.FileName>) (s.Pos #Output e.FileName #NoNative));

  (s.Pos #OutputWithNative (e.FileName) e.NativeFileName) =
    (
      (<GetBaseNameLowerCase e.FileName>)
      (s.Pos #Output e.FileName (e.NativeFileName))
    );

  (s.Pos #Source (e.Source) e.Output) =
    ((<GetBaseNameLowerCase e.Output>) (s.Pos #Source (e.Source) e.Output));
}

ScanCollisions {
  ((e.BaseName) e.Locations1)
  e.Files-B ((e.BaseName) e.Locations2) e.Files-E =
    <ScanCollisions
      e.Files-B ((e.BaseName) e.Locations1 e.Locations2) e.Files-E
    >;

  ((e.BaseName) e.Locations) e.Files =
    <RenameLocations e.Locations> <ScanCollisions e.Files>;

  /* пусто */ = /* всё */;
}

RenameLocations {
  e.Locations-B (s.Pos1 #Output e.FirstTarget t.FirstNative)
  e.Locations-M (s.Pos2 #Output e.SecondTarget t.SecondNative)
  e.Locations-E =
    (s.Pos2 #Collision (e.FirstTarget) e.SecondTarget);

  e.Locations-B (s.Pos #Output e.Target t.Native) e.Locations-E =
    <RenameLocations-Aux
      1 e.Locations-B (s.Pos #Output e.Target t.Native) e.Locations-E
    >;

  e.Locations = <RenameLocations-Aux 0 e.Locations>;
}

RenameLocations-Aux {
  s.InitNumber e.Locations =
    <DelAccumulator
      <MapReduce
        {
          0 (s.Pos #Source (e.Source) e.Output) =
            1 (s.Pos #Source (e.Source) e.Output);

          s.Num (s.Pos #Source (e.Source) e.Output '.cpp') =
            <Inc s.Num>
            (s.Pos #Source (e.Source) e.Output '@' <StrFromInt s.Num> '.cpp');

          s.Num (s.Pos #Output e.Output t.Native) =
            s.Num (s.Pos #Output e.Output t.Native);
        }
        s.InitNumber e.Locations
      >
    >;
}

CompileFiles {
  s.GenMode s.Opt s.MarkupContext e.Files =
    <Map
      {
        (s.Pos #Output e.OutputName #NoNative) =
          <WriteLine '+Linking ' e.OutputName>
          (e.OutputName);

        (s.Pos #Output e.OutputName (e.NativeName)) =
          <WriteLine '+Linking (+ natives) ' e.OutputName>
          (e.OutputName) (e.NativeName);

        (s.Pos #Source (e.Source) e.OutputName) =
          <WriteLine '*Compiling ' e.Source ':'>
          <Fetch
            <CompileFile
              s.GenMode s.Opt s.MarkupContext (e.Source) e.OutputName
            >
            {
              #Success e.OutputName^ #NoNative =
                (e.OutputName);

              #Success e.OutputName^ (e.NativeOutputName) =
                <WriteLine '   ... natives generated'>
                (e.OutputName) (e.NativeOutputName);

              #Fails = #Fails;
            }
          >;
      }
      e.Files
    >;
}

Link {
  #NoCppCompiler t.ErrorFile (e.TargetFileName) e.Files =
    /* ничего не делаем */;

  ((e.CommandLine) (e.Flags)) t.ErrorFile (e.TargetFileName) e.Files =
    <Fetch
      <ExistFile e.TargetFileName '.partial'>
      {
        #False =
          /* ничего не делаем */;

        #True =
          <Fetch
            <RemoveFile e.TargetFileName '.partial'>
            {
              #True =
                <WriteLine
                  'Lost temporary file ' e.TargetFileName '.partial is removed'
                >;

              #False =
                <LinkError
                  t.ErrorFile 'Can''t remove file ' e.TargetFileName '.partial'
                >;
            }
          >;
      }
    >
    <System
      e.CommandLine
      e.TargetFileName '.partial'
      e.Flags
      <Map
        {
          (e.FileName) = ' "' e.FileName '"';
        }
        e.Files
      >
    >
    <Fetch
      <ExistFile e.TargetFileName '.partial'>
      {
        #False =
          <LinkError t.ErrorFile 'C++ compilation is failed'>;

        #True =
          <Fetch
            <ExistFile e.TargetFileName>
            {
              #True =
                <Fetch
                  <RemoveFile e.TargetFileName>
                  {
                    #True =
                      <LinkError
                        t.ErrorFile 'Can''t remove file ' e.TargetFileName
                      >;

                    #False =
                      /* ничего не делаем */;
                   }
                 >;

              #False =
                /* ничего не делаем */;
            }
          >;
       }
     >
     <Fetch
       <RenameFile (e.TargetFileName '.partial') (e.TargetFileName)>
       {
         #True =
           <WriteLine '** Compilation successed **'>;

         #False =
           <LinkError
             t.ErrorFile
             'Can''t rename from ' e.TargetFileName '.partial to '
             e.TargetFileName
           >;
       }
    >;
}

LinkError {
  t.ErrorFile e.Message =
    <WriteLine 'LINK ERROR: ' e.Message>
    <CreateErrorFileMark t.ErrorFile>
    <Exit 1>;
}

GetBaseNameLowerCase {
  e.FileName '.cpp' = <Lower <GetLastPartName e.FileName>>;
}

GetLastPartName {
  e.FileName = <DoGetFileName e.FileName>;
}

DoGetFileName {
  e.FileName '/' = ;
  e.FileName '\\' = ;
  e.FileName s.Last = <DoGetFileName e.FileName> s.Last;
  = ;
}

Lower {
  e.String = <Map LowerChar e.String>;
}

LowerChar {
  s.Char =
    // Сначала мы проверяем, что символ является большой буквой
    <Fetch
      'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      {
        e.Uppers-B s.Char e.Uppers-E =
          // Символ является большой буквой, находим соответствующую маленькую
          <Fetch
            'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'
            {
              e.UpLo-B s.Char s.Lower e.UpLo-E = s.Lower;
            }
          >;

        e.Uppers = s.Char;
      }
    >;
}
