//FROM GetOpt
$EXTERN GetOpt;

//FROM GetOpt-CheckRepeated
$EXTERN GetOpt-CheckRepeated;

//FROM LibraryEx
$EXTERN Fetch, Seq, MapReduce, Map;

/**
  <ParseCommandLine e.Arguments>
    == #Success t.CppCompiler s.GenMode s.Opt t.ErrorFile s.MarkupContext
       t.TargetFileName (e.TargetSuffix) ((e.Folder)*) (s.ArgNum e.File)*
    == #Fails (s.ArgNum e.ErrorMessage)

  t.CppCompiler ::= #NoCppCompiler | ((e.CppCompiler) (e.Flags))
  s.GenMode ::= #OnlyDirect | #OnlyInterpret
  s.Opt ::= #OptNone | #OptPattern | #OptResult
  t.ErrorFile ::= #NoErrorFile | (#ErrorFile e.FileName)
  s.MarkupContext ::= #MarkupContext | #NoMarkupContext
  t.TargetFileName ::= (e.TargetFileName) | #DefaultTargetFileName
*/
$ENTRY ParseCommandLine {
  e.Arguments =
    <Fetch
      <GetOpt
        (
          (#CppCompiler #Required 'c' ('cpp-command'))
          (#Opt #Required 'O')
          (#ErrorFile #Required 'e' ('error-file'))
          (#MarkupContext #None ('markup-context'))
          (#SearchFolder #Required 'd' ('dir') ('directory'))
          (#CppFlags #Required 'CF' ('cppflags'))
          (#CppFlag #Required 'f' ('cppflag'))
          (#RuntimeFolder #Required 'D' ('runtime-dir') ('runtime-directory'))
          (#TargetFileName #Required 'o' ('target-file'))
          (#TargetSuffix #Required ('targsuffix') ('targetsuffix') ('targsuf'))
        )
        e.Arguments
      >
      <Seq
        {
          (e.Errors) e.Options =
            <GetOpt-CheckRepeated
              (
                #CppCompiler #Opt #ErrorFile #MarkupContext #TargetFileName
                #TargetSuffix
              )
              (e.Errors) e.Options
            >;
        }
        {
          (e.Errors)
          e.Options-B (#CppCompiler s.Num e.CppCompiler) e.Options-E =
            (e.Errors) (((e.CppCompiler) (/* flags */)))
            e.Options-B e.Options-E;

          (e.Errors) e.Options =
            (e.Errors) (#NoCppCompiler) e.Options;
        }
        {
          (e.Errors) (e.Bag) e.Options-B (#Opt s.Num e.Opt) e.Options-E =
            <Fetch
              <ParseOpt e.Opt>
              {
                #Success e.OptBag =
                  (e.Errors) (e.Bag e.OptBag) e.Options-B e.Options-E;

                #Fails =
                  (e.Errors (s.Num #BadValue-Opt e.Opt))
                  (e.Bag #OnlyInterpret #OptNone) e.Options-B e.Options-E;
              }
            >;

          (e.Errors) (e.Bag) e.Options =
            (e.Errors) (e.Bag #OnlyInterpret #OptNone) e.Options;
        }
        {
          (e.Errors) (e.Bag)
          e.Options-B (#ErrorFile s.Num e.ErrorFile) e.Options-E =
            (e.Errors) (e.Bag (#ErrorFile e.ErrorFile)) e.Options-B e.Options-E;

          (e.Errors) (e.Bag) e.Options =
            (e.Errors) (e.Bag #NoErrorFile) e.Options;
        }
        {
          (e.Errors) (e.Bag)
          e.Options-B (#MarkupContext s.Num) e.Options-E =
            (e.Errors) (e.Bag #MarkupContext) e.Options-B e.Options-E;

          (e.Errors) (e.Bag) e.Options =
            (e.Errors) (e.Bag #NoMarkupContext) e.Options;
        }
        {
          (e.Errors) (e.Bag)
          e.Options-B (#TargetFileName s.Num e.FileName) e.Options-E =
            (e.Errors) (e.Bag (e.FileName)) e.Options-B e.Options-E;

          (e.Errors) (e.Bag) e.Options =
            (e.Errors) (e.Bag #DefaultTargetFileName) e.Options;
        }
        {
          (e.Errors) (e.Bag)
          e.Options-B (#TargetSuffix s.Num e.Suffix) e.Options-E =
            (e.Errors) (e.Bag (e.Suffix)) e.Options-B e.Options-E;

          (e.Errors) (e.Bag) e.Options =
            (e.Errors) (e.Bag ('.EXE')) e.Options;
        }
        {
          (e.Errors) (e.Bag) e.Options =
            ((e.Errors) (e.Bag)) e.Options;
        }
        (MapReduce {
          ((e.Errors) (#NoCppCompiler e.Bag)) (#CppFlags s.Num e.Flags) =
            (
              (e.Errors (s.Num #FlagsForNoCompiler))
              (#NoCppCompiler e.Bag)
            );

          ((e.Errors) (#NoCppCompiler e.Bag)) (#CppFlag s.Num e.Flag) =
            (
              (e.Errors (s.Num #FlagsForNoCompiler))
              (#NoCppCompiler e.Bag)
            );

          ((e.Errors) (((e.CppCompiler) (e.Flags)) e.Bag))
          (#CppFlags s.Num e.NewFlags) =
            (
              (e.Errors)
              (((e.CppCompiler) (e.Flags ' ' e.NewFlags)) e.Bag)
            );

          ((e.Errors) (((e.CppCompiler) (e.Flags)) e.Bag))
          (#CppFlag s.Num e.Flag) =
            (
              (e.Errors)
              (((e.CppCompiler) (e.Flags ' "' e.Flag '"')) e.Bag)
            );

          ((e.Errors) (t.CppCompiler e.Bag)) (#RuntimeFolder s.Num e.Folder) =
            (
              (e.Errors)
              (
                <Fetch
                  t.CppCompiler {
                    #NoCppCompiler = #NoCppCompiler;
                    ((e.CppCompiler^) (e.Flags)) =
                      ((e.CppCompiler) (e.Flags ' -I"' e.Folder '"'));
                  }
                >
                e.Bag
              )
            )
            (#SearchFolder s.Num e.Folder);

          ((e.Errors) (e.Bag)) t.OtherOption =
            ((e.Errors) (e.Bag)) t.OtherOption;
        })
        {
          ((e.Errors) (e.Bag)) e.Options =
            (e.Errors) (e.Bag) e.Options;
        }
        {
          (e.Errors) (e.Bag) e.Options =
            (e.Errors)
            <MapReduce
              {
                (e.Bag^ (e.Folders)) (#SearchFolder s.Num e.Folder) =
                  (e.Bag (e.Folders (e.Folder)));

                (e.Bag^) (#FILE s.Num e.FileName) =
                  (e.Bag) (s.Num e.FileName);
              }
              (e.Bag ())
              e.Options
            >;
        }
        {
          () (e.Bag) e.FileNames = #Success e.Bag e.FileNames;

          (e.Errors) (e.Bag) e.FileNames =
            #Fails
            <Map
              {
                (s.Pos #NoRequiredParam e.Param) =
                  (s.Pos 'option ' e.Param ' expects parameter');

                (s.Pos #UnknownShortOption s.Option) =
                  (s.Pos 'unknown option -' s.Option);

                (s.Pos #UnknownLongOption e.Option) =
                  (s.Pos 'unknown option --' e.Option);

                // У нас все опции с параметрами, не должно возникать
                // (s.Pos #UnexpectedLongOptionParam (e.Option) e.Param) =

                (s.Pos #RepeatOption s.Tag) =
                  (
                    s.Pos
                    'option '
                    <Fetch
                      s.Tag {
                        #CppCompiler = '-c or --cpp-command';
                        #Opt = '-O';
                        #ErrorFile = '-e or --error-file';
                      }
                    >
                    ' must appear one time'
                  );

                (s.Pos #BadValue-Opt e.BadValue) =
                  (
                    s.Pos
                    'option -O expects ''P'', ''R'', ''d'' or '
                    'it''s combination, but got ''' e.BadValue ''
                  );

                (s.Pos #FlagsForNoCompiler) =
                  (
                    s.Pos
                    'options ''--cppflag'' (''-f'') and ''--cppflags'' '
                    '(''-C'', ''-F'') must be appear only with option '
                    '''--cppcommand'' (''-c'')'
                  );
              }
              e.Errors
            >;
        }
      >
    >;
}

ParseOpt {
  /* пустой список */ = #Fails;
  e.Opt-B 'd' e.Opt-E = <ParseOpt-Aux #OnlyDirect e.Opt-B e.Opt-E>;
  e.Opt = <ParseOpt-Aux #OnlyInterpret e.Opt>;
}

ParseOpt-Aux {
  s.GenMode 'P' = #Success s.GenMode #OptPattern;
  s.GenMode 'R' = #Success s.GenMode #OptResult;
  s.GenMode 'PR' = #Success s.GenMode #OptBoth;
  s.GenMode 'RP' = #Success s.GenMode #OptBoth;
  s.GenMode /* пусто */ = #Success s.GenMode #OptNone;
  s.GenMode e.Other = #Fails;
}
