//FROM LibraryEx
$EXTERN Fetch, Inc, Dec;


/**
  В данном модуле описывается контекст -- обобщение понятия таблицы
  переменных. Контекст позволяет отслеживать как правильность использования
  переменных (объявленность переменных, используемых в результатном выражении,
  уникальность переменной с данным именем и режимом (s, t или e)), так и
  отслеживать свободные и связанные переменные в данной функции -- собственно
  контекст, передаваемый в замыкания.

  ВНИМАНИЕ! Здесь используется терминология лямбда-исчисления:
  * Переменная называется СВЯЗАННОЙ, если она является аргументом данной
    лямбда-абстракции, т.е. первый раз связывается в данном образце.
  * Переменная называется СВОБОДНОЙ, если она не объявлена внутри данной
    лямбда-абстракции, т.е. она связана где-то вовне.
  Пример: \ac.abcd, переменные a и c — связанные, b и d — свободные.
*/

$ENUM Context;
/*
  Внутренняя структура контекста:
  [Context
    e.Variables1 (#FreeVarsSent e.FreeSent1) (#FreeVarsFunc e.FreeFunc1)
    e.Variables2 (#FreeVarsSent e.FreeSent2) (#FreeVarsFunc e.FreeFunc2)
    ...
    e.VariablesN (#FreeVarsSent) (#FreeVarsFunc)
  ]
  e.VariablesK, e.FreeSentK, e.FreeFuncK ::= (s.Mode e.Index)*

  e.VariablesK представляет собой набор связанных переменных -- переменных,
  упоминаемых в образце данного предложения K-го по вложенности тела функции.

  e.Free***K представляет собой набор свободных переменных K-го по вложенности
  тела функции (эти переменные являются повторными для образцового выражения,
  присутсвуют во внешних функциях).

  e.FreeSentK представляет собой список свободных переменных, обнаруженных
  во время анализа данного предложения. Список пополняется при появлении
  в образце либо в результате переменной, имеющейся в окружающем контексте.

  e.FreeFuncK представляет собой список свободных переменных, обнаруженных
  во всех предыдущих предложениях включительно. По завершении анализа предло-
  жения в e.FreeFuncK должны быть добавлены e.FreeSentK.

  e.Variables1 и e.Free***1 соответствуют самой вложенной функции,
  e.VariablesN -- глобальной функции (для глобальной функции отсутствует
  понятие свободных переменных).
*/

/**
  <Cntx-Create> == t.Context
*/
$ENTRY Cntx-Create {
  = [Context];
}

/**
  <Cntx-Destroy t.Context> == пусто
*/
$ENTRY Cntx-Destroy {
  [Context] = ;
}

/**
  <Cntx-AddVariable t.Context s.Mode e.Index>
    == t.Context # Success
    == t.Context # InvalidMode s.OldMode
*/
$ENTRY Cntx-AddVariable {
  [Context e.Variables-B (s.Mode e.Index) e.Variables-E]
  s.Mode e.Index =
    /*
      Идея тут в том, что если в e.Variables-B имеется хотя бы один
      (Free e.Free), то данная переменная является свободной для текущего
      функционального блока и её надо сохранить в список свободных переменных
      (из-за того, что переменные добавляются слева направо, этот список
      будет самым левым), что, собственно и делает функция ShiftVariable.

      На этот комментарий ссылаются из функции Cntx-CheckVariable.
    */
    [Context
      <ShiftVariable (s.Mode e.Index) e.Variables-B>
      (s.Mode e.Index)
      e.Variables-E
    ]
    # Success;

  [Context e.Variables-B (s.OldMode e.Index) e.Variables-E]
  s.NewMode e.Index =
    [Context e.Variables-B (s.OldMode e.Index) e.Variables-E]
    # InvalidMode s.OldMode;

  [Context e.Variables] s.Mode e.Index =
    [Context (s.Mode e.Index) e.Variables]
    # Success;
}

ShiftVariable {
  (s.Mode e.Index)
  e.Variables-B
  (#FreeVarsSent e.Free) (#FreeVarsFunc e.FreeFunc)
  e.Variables-E =
    e.Variables-B (s.Mode e.Index)
    (#FreeVarsSent <ShiftVariable-AddToFree (s.Mode e.Index) e.Free>)
    (#FreeVarsFunc e.FreeFunc)
    <ShiftVariable (s.Mode e.Index) e.Variables-E>;

  (s.Mode e.Index) e.Variables = e.Variables;
}

ShiftVariable-AddToFree {
  (s.Mode e.Index)
  e.Variables-B (s.Mode e.Index) e.Variables-E =
    e.Variables-B (s.Mode e.Index) e.Variables-E;

  (s.Mode e.Index) e.Variables =
    e.Variables (s.Mode e.Index);
}

/**
  <Cntx-AddNewVariable t.Context s.Mode e.Index>
    == t.Context # Success
    == t.Context # InvalidMode s.OldMode
    == t.Context # AlreadyBounded

  Эта функция в отличие от Cntx-AddVariable добавляет переменную как
  имеющую область видимости начиная с текущей функции: если в области
  видимости имеется переменная с тем же именем, что и в данной функции,
  то она сокрывается.
  Если переменная уже упоминалась ранее в текущем образце, функция возвращает
  # AlreadyBounded, что является ошибкой.
*/
$ENTRY Cntx-AddNewVariable {
  [Context
    e.LocalVars (#FreeVarsSent e.FreeSent) (#FreeVarsFunc e.FreeFunc) e.Stack
  ]
  s.Mode e.Index =
    <Fetch
      e.LocalVars
      {
        e.LocalVars-B (s.Mode e.Index) e.LocalVars-E =
          [Context
            e.LocalVars-B (s.Mode e.Index) e.LocalVars-E
            (#FreeVarsSent e.FreeSent) (#FreeVarsFunc e.FreeFunc)
            e.Stack
          ]
          # AlreadyBounded;

        e.LocalVars-B (s.OldMode e.Index) e.LocalVars-E =
          [Context
            e.LocalVars-B (s.OldMode e.Index) e.LocalVars-E
            (#FreeVarsSent e.FreeSent) (#FreeVarsFunc e.FreeFunc)
            e.Stack
          ]
          # InvalidMode s.OldMode;

        e.LocalVars^ =
          [Context
            (s.Mode e.Index) e.LocalVars
            (#FreeVarsSent e.FreeSent) (#FreeVarsFunc e.FreeFunc)
            e.Stack
          ]
          # Success;
      }
    >;
}

/**
  <Cntx-CheckVariable t.Context s.Mode e.Index>
    == t.Context # ExistVariable
    == t.Context # InvalidMode s.OldMode
    == t.Context # NotFound
*/
$ENTRY Cntx-CheckVariable {
  [Context e.Variables-B (s.Mode e.Index) e.Variables-E]
  s.Mode e.Index =
    [Context
      // См. комментарий в Cntx-AddVariable
      <ShiftVariable (s.Mode e.Index) e.Variables-B>
      (s.Mode e.Index)
      e.Variables-E
    ]
    # ExistVariable;

  [Context e.Variables-B (s.OldMode e.Index) e.Variables-E]
  s.NewMode e.Index =
    [Context e.Variables-B (s.OldMode e.Index) e.Variables-E]
    # InvalidMode s.OldMode;

  [Context e.Variables] s.Mode e.Index =
    [Context e.Variables] # NotFound;
}

/**
  <Cntx-ResetAfterSentence t.Context> == t.Context
*/
$ENTRY Cntx-ResetAfterSentence {
  [Context
    e.Locals (#FreeVarsSent e.FreeSent) (#FreeVarsFunc e.FreeFunc) e.Outers
  ] =
    [Context
      (#FreeVarsSent) (#FreeVarsFunc <Unique e.FreeSent e.FreeFunc>) e.Outers
    ];
}

Unique {
  e.Begin t.Copy e.Middle t.Copy e.End =
    e.Begin <Unique t.Copy e.Middle e.End>;

  e.Uniques = e.Uniques;
}

/**
  <Cntx-PushScope t.Context> == t.Context
*/
$ENTRY Cntx-PushScope {
  [Context e.Variables] =
    [Context (#FreeVarsSent) (#FreeVarsFunc) e.Variables];
}

/**
  <Cntx-PopScope t.Context>
    == t.Context
*/
$ENTRY Cntx-PopScope {
  [Context (#FreeVarsSent) (#FreeVarsFunc e.ClosureContext) e.Outers] =
    [Context e.Outers];
}
