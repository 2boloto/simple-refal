  Примечание. Сдвиг в нумерации "записок" связан с тем, что записка note004.txt
относилась к параллельной ветке развития Простого Рефала, представляющего собой
компилятор в Си Шапр. Настоящая версия представляет собой компилятор из Просто-
го Рефала в Си++ и основана на Simple Refal.004.

  Лаба проводилась в весеннем семестре 2010 года совместно со студентом 5 курса
кафедры ИУ9 Дорофеевым Михаилом, за что я ему выражаю огромную благодарность.

  Целью этой лабы изначально написание оптимизации результатного выражения пу-
тём путём построения результата функции путём модификации исходного аргумента
функции при помощи наименьшего количества модификаций последнего и наименьшего
количества распределений новой памяти. Однако, из-за особенностей проведения
исследования (для Дорофеева Михаила это был курсовой проект) и занятости Михаи-
ла лаба была выполнена лишь частично: подготовлен фундамент для полноценного
исследования и была проведена оптимизация по смежной теме (см. ниже). О работе
Михаила можно прочитать в расчётно-пояснительной записке (РПЗ_Дорофеев.doc), в
которой рабочий процесс и внесённые изменения рассмотрены очень подробно. Здесь
будут перечислены те результаты работы, которые не нашли отражения в записке.

  Изначально предполагалось, что будет разработан способ построения результат-
ного выражения путём минимальной модификации результата и минимального исполь-
зования списка свободных узлов. Например, для первого предложения функции Fab

  Fab {
    'A' e.Tail = 'B' <Fab e.Tail>;
    s.Other e.Tail = s.Other <Fab e.Tail>;
    /* пусто */ = /* пусто */;
  }

результатное выражение 'B' <Fab e.Tail> можно получить из активного выражения
<Fab 'A' e.Tail> или путём переноса атома 'B' за угловую скобку, или путём пе-
реинициализации скобки, имени Fab и символа 'A' соответственно в символ 'B',
угловую скобку и имя Fab. Первое требует одной операции splice, модифицирующей
6 слов (указатели prev и next у переносимого участка, в старом и новом располо-
жении), второе --- вызова трёх функций переинициализации (которые в силу своей
простоты могут быть сделаны inline), которые также в совокупности модифицируют
6 слов: тег и значение для 'A', только тег для левой скобки вызова и тег и зна-
чение для Fab (два указателя: на саму функцию и на текстовое представление име-
ни). Текущая же версия компилятора все элементы результата, кроме переменных,
переносимых из образца, распределяет в списке свободных узлов, а затем по одно-
му переносит (splice) их на место перед открывающей угловой скобкой. Затем, то,
что осталось между < и > выбрасывается в список свободных узлов (там остаются
литеральные элементы, которые задавались константами в образцовом выражении и
неиспользованные переменные). Можно оценить, сколько в таком случае понадобит-
ся модифицировать слов. Распределяются вновь элементы 'B', <, Fab и >, т.е.
модифицируется 2 + 1 + 3 + 1 = 7 слов, для каждого распределения смещается ука-
затель на свободный узел, т.е. плюс ещё 4 слова, перенос каждого элемента тре-
бует 4 * 6 = 24 слова, перенос остатков в список свободных узлов --- 6 слов.
Итого 7 + 4 + 24 + 6 = 41 слово. И это без учёта затрат на вызовы функций. Те-
кущая версия совершает (в данном примере) примерно в 7 раз больше модификаций
слов, чем оптимальная версия. При этом более половины из этих операций (24 /
/ 41 = 59 %) это затраты на перенос элементов по одному. Перенося кусок
'B' <Fab за один сплайс, можно сэкономить 3 * 6 - 6 = 12 модификаций слов, т.е.
примерно 30 %.
  Очевидно, что такая оптимизация, т.е. переделка аргумента в результат, должна
повышать производительность программы, поскольку очень часто (особенно, в оста-
точно-рекурсивных функциях) результат замены активного выражения по структуре
не очень сильно отличается от исходного активного выражения, что, например, де-
монстрирует следующий вариант функции Fab:

  Fab2 { e.String = <DoFab2 () e.String>; }

  DoFab2 {
    (e.Scanned) 'A' e.Tail = <DoFab2 (e.Scanned 'B') e.Tail>;
    (e.Scanned) s.Other e.Tail = <DoFab2 (e.Scanned s.Other) e.Tail>;
    (e.Scanned) /* пусто */ = e.Scanned;
  }

  Очевидно, что в оптимальной версии в первом предложении достаточно только пе-
реинициализировать скобку и литеру (модификация трёх слов), во втором --- поме-
нять местами скобку и s-переменную (6 слов). Очевидно, что неоптимизированная
версия сделала бы целую уйму распределений новых элементов и их операций пере-
носа. (Не следует думать, что эта версия Fab в случае оптимальной компиляции
будет быстрее предыдущей (три слова против шести), т.к. здесь требуется распоз-
навать в образце скобки.) Пример с Fab надуман (как и сама функция Fab), но по-
добного рода остаточно-рекурсивные циклы очень широко применяются при програм-
мировании на Рефале со списковой реализацией.
  Однако, следует помнить, что в текущей версии Простого Рефала образцовые вы-
ражения обрабатываются независимо, т.е. каждый обработчик предложения начинает
сопоставление с образцом с нераспознанного выражения, т.е. не учитывая, на
сколько продвинулись в распознавании предыдущие предложения. (Часто образцы
нескольких предложений имеют общую структуру (как в примере с DoFab2), учёт ко-
торой заметно ускорил бы программу.) Поэтому, сопоставления с образцами выпол-
няются в несколько раз чаще, чем построения результатов и высокого прироста
скорости выполнения ожидать от оптимизации результата не следует.
  Одним из способов поиска оптимального построения результата может быть моди-
фикация алгоритма поиска наибольшей общей подстроки. Времязатраты порядка M*N
при наличии прямоугольной таблицы с произвольным доступом за постоянное время.
На списковой реализации Рефала возможна эмуляция такой таблицы со временем дос-
тупа O(M+N), поэтому можно ожидать времязатраты порядка третьей степени от дли-
ны образца и результата. Здесь M --- длина образцового выражения, N --- длина
результатного выражения. Определённые модификации алгоритма позволяют получать
сложность меньше квадратичной при условии, что сравниваемые строки похожи, что
типично для Рефала (иначе мы бы не делали такой оптимизации).

  Результаты.
  1. Вследствие занятости Михаила пришлось изменить предмет исследования. Вмес-
то оптимизации путём поиска наименьшего числа модификаций аргумента исследова-
лась оптимизация путём переиспользования элементов аргумента (т.е. без распре-
делений памяти в списке свободных узлов).
  Как и для исходного предмета исследований, так и для нового предмета исследо-
ваний, требуется сохранять указатели на распознанные элементы аргумента, что
исходная версия Простого Рефала не делала. В исходной версии операции сопостав-
ления с образцом имели вид

  if( ! char_left( 'A', bb_0, be_0 ) )
    break;

т.е. позиции распознанных элементов нигде не сохранялись. Сначала предполага-
лось использовать двухступенчатый подход --- сначала обнаруживать терм, потом
определять, чем же он является:

  refalrts::Iter n2 = 0;
  if( ! tvar_left( n2, bb_0, be_0 ) )
    break;
  if( ! char_match( 'A', n2 ) )
    break;

  Такой подход действительно позволял сохранить позиции элементов и был реали-
зован. Преимуществом являлось то, что его можно было бы использовать и при
дальнейших исследованиях оптимизации образца, т.к. можно однократно найти терм
и потом проверять разные гипотезы, чем конкретно он является. Недостатком ока-
залось неприлично низкое быстродействие, что было определено экспериментально.
  Поэтому от использования этого подхода пришлось отказаться (но в refalrts.h
остались функции с суффиксом _match) и поступить иначе --- заставить функции с
суффисками _left и _right возвращать указатель на сопоставленный элемент или
NULL в случае невозможности сопоставления. Это обеспечивает обратную совмести-
мость, т.к. ненулевые указатели приводятся к true, а нулевые --- к false. Поэ-
тому теперь команды сопоставления с образцом имеют вид:

  refalrts::Iter n2;
  if( (n2 = char_left( 'A', bb_0, be_0 )) == 0 )
    break;
  refalrts::use( n2 );

  Поскольку анализ дальнейшей используемости позиций элементов аргумента не
проводится (т.е. переменная n2 может оказаться и неиспользуемой), а некоторые
компиляторы (в частности Borland C++ Compiler 5.5) к инициализированным и не-
используемым переменным относятся строго (выдают предупреждения, а затем и
ошибку "Слишком много предупреждений"), пришлось добавить бесполезную функцию
refalrts::use, которая подавляет это предупреждение.
  Этот базис, т.е. сохранение позиций аргумента, можно использовать и для дру-
гой лабы, которая будет посвящена исходному предмету исследования.
  2. Оптимизация построения результата здесь свелась к повторному использова-
нию элементов аргумента (атомов и скобок) и переносу фрагментов большими кус-
ками (групповой splice).
  Переиспользование делилось на две группы: переиспользование элемента без пе-
реинициализации --- когда узел только переносится на новое место, и переисполь-
зование с переинициализацией, когда узел переинициализируется и переносится на
новое место. Второй вид переиспользования по быстродействию почти не отличается
от инициализации узла в списке свободных узлов, отличие сводится лишь к отсут-
ствии проверки на недостаток памяти и перемещению указателя на следующий узел.
  Сначала была написана версия без группового переноса элементов, но это дало
ничтожный (но измеримый) прирост производительности. Поэтому потом был добавлен
групповой перенос, который дал более заметное повышение скорости выполнения.
  Есть пока не проверенное подозрение, что групповой перенос из списка свобод-
ных узлов без переиспользования (или хотя бы частичного переиспользования), дал
бы ещё большее ускорение, т.к. группы не дробились бы на куски из-за того, что
часть из них находится в аргументе, а часть --- в списке свободных узлов. Воз-
можно, когда-нибудь проверю.
  3. Как и в случае исследования, посвящённого исследованию режима интерпрета-
ции, целевой код одновременно содержал несколько вариантов кода, нужный выби-
рался при помощи макросов препроцессора. В текущем исследовании (см. РПЗ) целе-
вой код содержал 3 варианта кода: с использованием старого сопоставления с об-
разцом и старой генерации результата, модифицированное сопоставление с образцом
и старая генерация результата, модифицированное сопоставление с образцом и мо-
дифицированная генерация результата.
  4. К сожалению, работа проводилась в спешке, что плохо сказалось на качестве
исходного кода, в частности, нарушилась модульная организация исходников (те-
перь уже зависимости между исходниками не описываются ациклическим графом); по-
явилось много кода, отформатированного в другом стиле (в отличии от основного
массива кода): строки длиннее 80 символов, выравнивание по вертикали; местами
код стал более сумбурным.
  Эти недостатки устранимы, но пока я всё оставлю как есть. При дальнейшей ра-
боте в этом направлении эти недостатки могут быть исправлены.